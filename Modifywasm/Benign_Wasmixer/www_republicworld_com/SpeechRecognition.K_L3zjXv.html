<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SpeechRecognition.K_L3zjXv.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABCAJgAABgAAF/AiQDA3VjdQRob2hqAAEDbGVhBmp6d2ZlZAAAA2hqbQRrdnJ3AAADAgEABAUBcAAECQUDAQABBxECBm1lbW9yeQIABG9lbXcAAwkKAQBBAQsEAQACAwoeARwAAkADQEECEQEARQ0BQQMRAABBAREAAAwACwsL';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABCAJgAABgAX8AAh8CA3dhcghkZW1jZmxwYgAAA3p2awhmenFnZWx1ZgAAAwIBAQQFAXAAAwgFAwEAAQcRAgZtZW1vcnkCAAR4dGFjAAIJCQEAQQELAwEAAgoOAQwAIAAEQBAABRABCws=';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABBAFgAAACDwEDenVmB21hcGRpZ24AAAMCAQAEBQFwAAIHBQMBAAEHEQIGbWVtb3J5AgAEc3BmcQABCQgBAEEBCwIAAQoJAQcAQQERAAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG+4GAgAArfwBBAQt/AEEKC38AQQwLfwBBEgt/AEEeC38AQSoLfwBBLAt/AEE6C38AQdAAC38AQeQAC38AQfYAC38AQYIBC38AQZoBC38AQagBC38AQboBC38AQdYBC38AQdgBC38AQdoBC38AQeIBC38AQeoBC38AQfgBC38AQfoBC38AQfwBC38AQf4BC38AQYACC38AQYgCC38AQYwCC38AQZQCC38AQZoCC38AQaICC38AQaQCC38AQaoCC38AQawCC38AQa4CC38AQbICC38AQb4CC38AQdACC38AQeQCC38AQe4CC38AQYIDC38AQYgDC38AQY4DC38AQZIDCweDg4CAACwGbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgFZGF0YTkDCQZkYXRhMTADCgZkYXRhMTEDCwZkYXRhMTIDDAZkYXRhMTMDDQZkYXRhMTQDDgZkYXRhMTUDDwZkYXRhMTYDEAZkYXRhMTcDEQZkYXRhMTgDEgZkYXRhMTkDEwZkYXRhMjADFAZkYXRhMjEDFQZkYXRhMjIDFgZkYXRhMjMDFwZkYXRhMjQDGAZkYXRhMjUDGQZkYXRhMjYDGgZkYXRhMjcDGwZkYXRhMjgDHAZkYXRhMjkDHQZkYXRhMzADHgZkYXRhMzEDHwZkYXRhMzIDIAZkYXRhMzMDIQZkYXRhMzQDIgZkYXRhMzUDIwZkYXRhMzYDJAZkYXRhMzcDJQZkYXRhMzgDJgZkYXRhMzkDJwZkYXRhNDADKAZkYXRhNDEDKQZkYXRhNDIDKgvPhICAACsAQQELB3N5bWJvbAAAQQoLAQAAQQwLBCUyMAAAQRILCnVuZGVmaW5lZAAAQR4LCnVuZGVmaW5lZAAAQSoLAQAAQSwLDHJlY29nbml0aW9uAABBOgsVcGF1c2VBZnRlckRpc2Nvbm5lY3QAAEHQAAsSaW50ZXJpbVRyYW5zY3JpcHQAAEHkAAsQZmluYWxUcmFuc2NyaXB0AABB9gALCmxpc3RlbmluZwAAQYIBCxZpc01pY3JvcGhvbmVBdmFpbGFibGUAAEGaAQsMc3Vic2NyaWJlcnMAAEGoAQsQb25TdG9wTGlzdGVuaW5nAABBugELG3ByZXZpb3VzUmVzdWx0V2FzRmluYWxPbmx5AABB1gELAQAAQdgBCwEAAEHaAQsGQUJPUlQAAEHiAQsGUkVTRVQAAEHqAQsMbm90LWFsbG93ZWQAAEH4AQsBAABB+gELAQAAQfwBCwEAAEH+AQsBAABBgAILBlJFU0VUAABBiAILA2VuAABBjAILBkFCT1JUAABBlAILBVNUT1AAAEGaAgsHb2JqZWN0AABBogILAQAAQaQCCwQlMjAAAEGqAgsBAABBrAILAQAAQa4CCwJpAABBsgILCiU1QyUyNCUyNgAAQb4CCxAoJTNGJTNBJTI0MSklM0YAAEHQAgsTKCU1QiU1RSU1Q3MlNUQlMkIpAABB5AILCCguKiUzRikAAEHuAgsSJTVDcyolMjQxJTNGJTVDcyoAAEGCAwsEJTVFAABBiAMLBCUyNAAAQY4DCwJpAABBkgMLBmVuLVVTAA=='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
var i = Object.defineProperty, t = (t, n, s) => (((t, n, s) => {
        n in t ? i(t, n, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: s
        }) : t[n] = s;
    })(t, lS(0, 0) != typeof n ? n + lS(0, 1) : n, s), s);
import {
    w as n,
    d as s
} from './index.CXi0gp2T.js';
import { a4 as e } from './scheduler.Ce454wGl.js';
const r = (...i) => i.map(i => i.trim()).join(lS(0, 2)).trim(), o = /\s*\((.*?)\)\s*/g, a = /(\(\?:[^)]+\))\?/g, c = /(\(\?)?:\w+/g, h = /\*/g, g = /[-{}[\]+?.,\\^$|#]/g, l = () => lS(0, 3) != typeof window && void 0 !== window.navigator && void 0 !== window.navigator.mediaDevices && void 0 !== window.navigator.mediaDevices.getUserMedia && (void 0 !== window.AudioContext || void 0 !== window.webkitAudioContext), p = () => /(android)/i.test(lS(0, 4) != typeof navigator ? navigator.userAgent : lS(0, 5)), u = navigator.brave ? null : window.SpeechRecognition || window.webkitSpeechRecognition;
class b {
    constructor(i) {
        t(this, lS(0, 6)), t(this, lS(0, 7)), t(this, lS(0, 8)), t(this, lS(0, 9)), t(this, lS(0, 10)), t(this, lS(0, 11)), t(this, lS(0, 12)), t(this, lS(0, 13)), t(this, lS(0, 14)), this.recognition = null, this.pauseAfterDisconnect = !1, this.interimTranscript = lS(0, 15), this.finalTranscript = lS(0, 16), this.listening = n(!1), this.isMicrophoneAvailable = !0, this.subscribers = {}, this.onStopListening = () => {
        }, this.previousResultWasFinalOnly = !1, this.resetTranscript = this.resetTranscript.bind(this), this.startListening = this.startListening.bind(this), this.stopListening = this.stopListening.bind(this), this.abortListening = this.abortListening.bind(this), this.setSpeechRecognition = this.setSpeechRecognition.bind(this), this.disableRecognition = this.disableRecognition.bind(this), this.setSpeechRecognition(i), p() && (this.updateFinalTranscript = ((i, t, n, ...s) => {
            let e;
            return () => {
                const r = void 0, o = [
                        i,
                        t,
                        n,
                        ...s
                    ], a = n && !e;
                clearTimeout(e), e = setTimeout(function () {
                    e = void 0, n || i.apply(r, o);
                }, t), a && i.apply(r, o);
            };
        })(this.updateFinalTranscript, 250, !0));
    }
    setSpeechRecognition(i) {
        const t = !!i && ((i => i === u)(i) || l());
        t && (this.disableRecognition(), this.recognition = new i(), this.recognition.continuous = !1, this.recognition.interimResults = !0, this.recognition.onresult = this.updateTranscript.bind(this), this.recognition.onend = this.onRecognitionDisconnect.bind(this), this.recognition.onerror = this.onError.bind(this));
    }
    subscribe(i, t) {
        this.subscribers[i] = t;
    }
    unsubscribe(i) {
        delete this.subscribers[i];
    }
    emitListeningChange(i) {
        this.listening.set(i), Object.keys(this.subscribers).forEach(t => {
            const {onListeningChange: n} = this.subscribers[t];
            (() => {
                const __callInstance14 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            n(i);
                        }
                    }
                });
                const __exports = __callInstance14.exports;
                return __exports.data();
            })();
        });
    }
    emitMicrophoneAvailabilityChange(i) {
        this.isMicrophoneAvailable = i, Object.keys(this.subscribers).forEach(t => {
            const {onMicrophoneAvailabilityChange: n} = this.subscribers[t];
            (() => {
                const __callInstance13 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            n(i);
                        }
                    }
                });
                const __exports = __callInstance13.exports;
                return __exports.data();
            })();
        });
    }
    emitTranscriptChange(i, t) {
        (() => {
            const __callInstance12 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.keys(this.subscribers).forEach(n => {
                            const {onTranscriptChange: s} = this.subscribers[n];
                            (() => {
                                const __callInstance11 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            s(i, t);
                                        }
                                    }
                                });
                                const __exports = __callInstance11.exports;
                                return __exports.data();
                            })();
                        });
                    }
                }
            });
            const __exports = __callInstance12.exports;
            return __exports.data();
        })();
    }
    emitClearTranscript() {
        (() => {
            const __callInstance10 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.keys(this.subscribers).forEach(i => {
                            const {onClearTranscript: t} = this.subscribers[i];
                            (() => {
                                const __callInstance9 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            t();
                                        }
                                    }
                                });
                                const __exports = __callInstance9.exports;
                                return __exports.data();
                            })();
                        });
                    }
                }
            });
            const __exports = __callInstance10.exports;
            return __exports.data();
        })();
    }
    disconnect(i) {
        if (this.recognition && e(this.listening))
            switch (i) {
            case lS(0, 17):
                this.pauseAfterDisconnect = !0, this.abort();
                break;
            case lS(0, 18):
                this.pauseAfterDisconnect = !1, this.abort();
                break;
            default:
                this.pauseAfterDisconnect = !0, this.stop();
            }
    }
    disableRecognition() {
        this.recognition && (this.recognition.onresult = () => {
        }, this.recognition.onend = () => {
        }, this.recognition.onerror = () => {
        }, e(this.listening) && this.stopListening());
    }
    onError(i) {
        i && i.error && lS(0, 19) === i.error && (this.emitMicrophoneAvailabilityChange(!1), this.disableRecognition());
    }
    onRecognitionDisconnect() {
        this.onStopListening(), this.listening.set(!1), this.pauseAfterDisconnect ? this.emitListeningChange(!1) : this.recognition && (this.recognition.continuous ? this.startListening({ continuous: this.recognition.continuous }) : this.emitListeningChange(!1)), this.pauseAfterDisconnect = !1;
    }
    updateTranscript({
        results: i,
        resultIndex: t
    }) {
        const n = void 0 === t ? i.length - 1 : t;
        this.interimTranscript = lS(0, 20), this.finalTranscript = lS(0, 21);
        (() => {
            let e = n;
            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return e < i.length ? 1 : 0;
                    },
                    update: () => {
                        ++e;
                    },
                    body: () => {
                        i[e].isFinal && (!p() || i[e][0].confidence > 0) ? this.updateFinalTranscript(i[e][0].transcript) : this.interimTranscript = r(this.interimTranscript, i[e][0].transcript);
                    }
                }
            });
            const __exports = __forInstance0.exports;
            return __exports.data();
        })();
        let s = !1;
        lS(0, 22) === this.interimTranscript && lS(0, 23) !== this.finalTranscript ? (this.previousResultWasFinalOnly && (s = !0), this.previousResultWasFinalOnly = !0) : this.previousResultWasFinalOnly = !1, s || this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);
    }
    updateFinalTranscript(i) {
        this.finalTranscript = r(this.finalTranscript, i);
    }
    resetTranscript() {
        (() => {
            const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        this.disconnect(lS(0, 24));
                    }
                }
            });
            const __exports = __callInstance8.exports;
            return __exports.data();
        })();
    }
    async startListening({
        continuous: i = !1,
        language: t = lS(0, 25)
    } = {}) {
        if (!this.recognition)
            return;
        const n = i !== this.recognition.continuous, s = t && t !== this.recognition.lang;
        (() => {
            const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            this.recognition.continuous || (this.resetTranscript(), this.emitClearTranscript());
                            try {
                                await this.start(), this.emitListeningChange(!0);
                            } catch (r) {
                                r instanceof DOMException || this.emitMicrophoneAvailabilityChange(!1);
                            }
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance0.exports;
            return __exports.data(((n || s) && (e(this.listening) && await this.stopListening(), this.recognition.continuous = n ? i : this.recognition.continuous, this.recognition.lang = s ? t : this.recognition.lang), !e(this.listening)) ? 1 : 0);
        })();
    }
    async abortListening() {
        this.disconnect(lS(0, 26)), this.emitListeningChange(!1), await new Promise(i => {
            this.onStopListening = i;
        });
    }
    async stopListening() {
        this.disconnect(lS(0, 27)), this.emitListeningChange(!1), await new Promise(i => {
            this.onStopListening = i;
        });
    }
    getRecognition() {
        return this.recognition;
    }
    async start() {
        this.recognition && !e(this.listening) && (await this.recognition.start(), this.listening.set(!0));
    }
    stop() {
        this.recognition && e(this.listening) && (this.recognition.stop(), this.listening.set(!1));
    }
    abort() {
        this.recognition && e(this.listening) && (this.recognition.abort(), this.listening.set(!1));
    }
}
let m, d = !!u, T = d && !p();
const f = ({
        transcribing: i = !0,
        clearTranscriptOnListen: t = !0,
        commands: r = []
    } = {}) => {
        const l = w.getRecognitionManager(), p = n(i), u = n({
                interimTranscript: '',
                finalTranscript: []
            }), b = n(t), m = s(l.listening, i => i), f = s(u, i => i.interimTranscript), y = s(u, i => i.finalTranscript), v = d, R = T;
        let L = l.isMicrophoneAvailable;
        const S = () => {
                (() => {
                    const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                u.set({
                                    interimTranscript: '',
                                    finalTranscript: []
                                });
                            }
                        }
                    });
                    const __exports = __callInstance7.exports;
                    return __exports.data();
                })();
            }, C = () => {
                l.resetTranscript(), S();
            }, A = (i, t, n) => {
                const s = (lS(0, 28) == typeof i ? i.toString() : i).replace(/[&/\\#,+()!$~%.'":*?<>{}]/g, lS(0, 29)).replace(/  +/g, lS(0, 30)).trim(), e = ((i, t) => {
                        if (i = i.replace(/\s+/g, lS(0, 31)).toLowerCase(), t = t.replace(/\s+/g, lS(0, 32)).toLowerCase(), !i.length && !t.length)
                            return 1;
                        if (!i.length || !t.length)
                            return 0;
                        if (i === t)
                            return 1;
                        if (1 === i.length && 1 === t.length)
                            return 0;
                        if (i.length < 2 || t.length < 2)
                            return 0;
                        const n = new Map();
                        (() => {
                            let e = 0;
                            const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return e < i.length - 1 ? 1 : 0;
                                    },
                                    update: () => {
                                        e++;
                                    },
                                    body: () => {
                                        {
                                            const t = i.substring(e, e + 2), s = n.has(t) ? n.get(t) + 1 : 1;
                                            (() => {
                                                const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            n.set(t, s);
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance6.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                }
                            });
                            const __exports = __forInstance1.exports;
                            return __exports.data();
                        })();
                        let s = 0;
                        (() => {
                            let e = 0;
                            const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return e < t.length - 1 ? 1 : 0;
                                    },
                                    update: () => {
                                        e++;
                                    },
                                    body: () => {
                                        {
                                            const i = t.substring(e, e + 2), r = n.has(i) ? n.get(i) : 0;
                                            r > 0 && (n.set(i, r - 1), s++);
                                        }
                                    }
                                }
                            });
                            const __exports = __forInstance2.exports;
                            return __exports.data();
                        })();
                        return 2 * s / (i.length + t.length - 2);
                    })(s, t);
                return e >= n ? {
                    command: i,
                    commandWithoutSpecials: s,
                    howSimilar: e,
                    isFuzzyMatch: !0
                } : null;
            }, M = (i, t) => {
                const n = (i => i instanceof RegExp ? new RegExp(i.source, lS(0, 33)) : (i = i.replace(g, lS(0, 34)).replace(o, lS(0, 35)).replace(c, (i, t) => t ? i : lS(0, 36)).replace(h, lS(0, 37)).replace(a, lS(0, 38)), new RegExp(lS(0, 39) + i + lS(0, 40), lS(0, 41))))(i), s = n.exec(t);
                return s ? {
                    command: i,
                    parameters: s.slice(1)
                } : null;
            }, O = w.counter;
        w.counter += 1;
        const E = {
            onListeningChange: i => l.listening.set(i),
            onMicrophoneAvailabilityChange: i => L = i,
            onTranscriptChange: (i, t) => {
                e(p) && u.update(n => (n.interimTranscript = i, t && (n.finalTranscript = [
                    ...n.finalTranscript,
                    t
                ]), n)), ((i, t) => {
                    (() => {
                        const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    r.forEach(({
                                        command: n,
                                        callback: s,
                                        matchInterim: e = !1,
                                        isFuzzyMatch: r = !1,
                                        fuzzyMatchingThreshold: o = 0.8,
                                        bestMatchOnly: a = !1
                                    }) => {
                                        var c, h, g;
                                        const l = !t && e ? i.trim() : t.trim(), p = (Array.isArray(n) ? n : [n]).map(i => r ? A(i, l, o) : M(i, l)).filter(i => i);
                                        (() => {
                                            const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        {
                                                            (() => {
                                                                const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                                                                    env: {
                                                                        impFunc: () => {
                                                                            p.sort((i, t) => t.howSimilar - i.howSimilar);
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __callInstance4.exports;
                                                                return __exports.data();
                                                            })();
                                                            const i = null == (c = p[0]) ? void 0 : c.command, t = null == (h = p[0]) ? void 0 : h.commandWithoutSpecials, n = null == (g = p[0]) ? void 0 : g.howSimilar;
                                                            (() => {
                                                                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                                                                    env: {
                                                                        impFunc: () => {
                                                                            s(t, l, n, {
                                                                                command: i,
                                                                                resetTranscript: C
                                                                            });
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __callInstance3.exports;
                                                                return __exports.data();
                                                            })();
                                                        }
                                                    },
                                                    impFunc2: () => {
                                                        (() => {
                                                            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                                                env: {
                                                                    impFunc: () => {
                                                                        p.forEach(i => {
                                                                            (() => {
                                                                                const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                                                                                    env: {
                                                                                        impFunc1: () => {
                                                                                            {
                                                                                                const {
                                                                                                    command: t,
                                                                                                    commandWithoutSpecials: n,
                                                                                                    howSimilar: e
                                                                                                } = i;
                                                                                                (() => {
                                                                                                    const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                                                                                        env: {
                                                                                                            impFunc: () => {
                                                                                                                s(n, l, e, {
                                                                                                                    command: t,
                                                                                                                    resetTranscript: C
                                                                                                                });
                                                                                                            }
                                                                                                        }
                                                                                                    });
                                                                                                    const __exports = __callInstance1.exports;
                                                                                                    return __exports.data();
                                                                                                })();
                                                                                            }
                                                                                        },
                                                                                        impFunc2: () => {
                                                                                            {
                                                                                                const {
                                                                                                    command: t,
                                                                                                    parameters: n
                                                                                                } = i;
                                                                                                (() => {
                                                                                                    const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                                                                                                        env: {
                                                                                                            impFunc: () => {
                                                                                                                s(...n, {
                                                                                                                    command: t,
                                                                                                                    resetTranscript: C
                                                                                                                });
                                                                                                            }
                                                                                                        }
                                                                                                    });
                                                                                                    const __exports = __callInstance0.exports;
                                                                                                    return __exports.data();
                                                                                                })();
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                });
                                                                                const __exports = __ifInstance2.exports;
                                                                                return __exports.data(i.isFuzzyMatch ? 1 : 0);
                                                                            })();
                                                                        });
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __callInstance2.exports;
                                                            return __exports.data();
                                                        })();
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance1.exports;
                                            return __exports.data(r && a && p.length >= 2 ? 1 : 0);
                                        })();
                                    });
                                }
                            }
                        });
                        const __exports = __callInstance5.exports;
                        return __exports.data();
                    })();
                })(i, t);
            },
            onClearTranscript: () => {
                e(b) && S();
            }
        };
        return l.subscribe(O, E), {
            transcribing: p,
            clearTranscriptOnListen: b,
            listening: m,
            isMicrophoneAvailable: L,
            resetTranscript: C,
            browserSupportsSpeechRecognition: v,
            browserSupportsContinuousListening: R,
            transcriptStore: u,
            interimTranscript: f,
            finalTranscript: y
        };
    }, w = {
        counter: 0,
        applyPolyfill: i => {
            m ? m.setSpeechRecognition(i) : m = new b(i);
            const t = !!i && l();
            d = t, T = t;
        },
        getRecognitionManager: () => (m || (m = new b(u)), m),
        getRecognition: () => w.getRecognitionManager().getRecognition(),
        startListening: async ({
            continuous: i = !1,
            language: t = lS(0, 42)
        } = {}) => {
            const n = w.getRecognitionManager();
            await n.startListening({
                continuous: i,
                language: t
            });
        },
        stopListening: async () => {
            const i = w.getRecognitionManager();
            await i.stopListening();
        },
        abortListening: async () => {
            const i = w.getRecognitionManager();
            await i.abortListening();
        },
        browserSupportsSpeechRecognition: () => d,
        browserSupportsContinuousListening: () => T
    };
export {
    w as S,
    f as u
};</script>
</body>
</html>
