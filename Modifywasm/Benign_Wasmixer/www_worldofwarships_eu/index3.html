<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>index3.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABCAJgAABgAAF/AiQDA3N5dARpYW91AAEDbHp1BmlwZm5lbwAAA2lmeARsa3FkAAADAgEABAUBcAAECQUDAQABBxECBm1lbW9yeQIABHpod3IAAwkKAQBBAQsEAQIDAAoeARwAAkADQEEEEQEARQ0BQQIRAABBAREAAAwACwsL';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABCAJgAABgAX8AAh8CA3Vmcwhzam5vdnFwdAAAA2Rwdwh0bWpoaHpwdwAAAwIBAQQFAXAAAwgFAwEAAQcRAgZtZW1vcnkCAAR6dWdpAAIJCQEAQQELAwIBAAoOAQwAIAAEQBAABRABCws=';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABBAFgAAACDwEDenFyB3Z0c3ZqZXcAAAMCAQAEBQFwAAIHBQMBAAEHEQIGbWVtb3J5AgAEYm9jcgABCQgBAEEBCwIBAAoJAQcAQQIRAAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGoYGAgAAcfwBBAQt/AEEKC38AQRoLfwBBJgt/AEEsC38AQTALfwBBOgt/AEE+C38AQcIAC38AQcYAC38AQcoAC38AQc4AC38AQdIAC38AQdoAC38AQaABC38AQaQBC38AQaYBC38AQagBC38AQaoBC38AQegBC38AQfABC38AQawCC38AQbYCC38AQb4CC38AQcgCC38AQdACC38AQY4DC38AQZYDCwf8gYCAAB0GbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgFZGF0YTkDCQZkYXRhMTADCgZkYXRhMTEDCwZkYXRhMTIDDAZkYXRhMTMDDQZkYXRhMTQDDgZkYXRhMTUDDwZkYXRhMTYDEAZkYXRhMTcDEQZkYXRhMTgDEgZkYXRhMTkDEwZkYXRhMjADFAZkYXRhMjEDFQZkYXRhMjIDFgZkYXRhMjMDFwZkYXRhMjQDGAZkYXRhMjUDGQZkYXRhMjYDGgZkYXRhMjcDGwuVhICAABwAQQELB29iamVjdAAAQQoLDm1hcE9iamVjdFNraXAAAEEaCwpfX3Byb3RvX18AAEEmCwQlNUUAAEEsCwNndQAAQTALCCU1Q2QlMkIAAEE6CwNndQAAQT4LAi0AAEHCAAsCLQAAQcYACwItAABBygALAl8AAEHOAAsCLQAAQdIACwdzdHJpbmcAAEHaAAtFRXhwZWN0ZWQlMjB0aGUlMjBpbnB1dCUyMHRvJTIwYmUlMjAlNjBzdHJpbmclMjAlN0MlMjBzdHJpbmclNUIlNUQlNjAAAEGgAQsCLQAAQaQBCwEAAEGmAQsBAABBqAELAQAAQaoBCzwlNjBtYXhTaXplJTYwJTIwbXVzdCUyMGJlJTIwYSUyMG51bWJlciUyMGdyZWF0ZXIlMjB0aGFuJTIwMAAAQegBCwdudW1iZXIAAEHwAQs7JTYwbWF4QWdlJTYwJTIwbXVzdCUyMGJlJTIwYSUyMG51bWJlciUyMGdyZWF0ZXIlMjB0aGFuJTIwMAAAQawCCwlmdW5jdGlvbgAAQbYCCwdudW1iZXIAAEG+AgsJZnVuY3Rpb24AAEHIAgsHbnVtYmVyAABB0AILPCU2MG1heFNpemUlNjAlMjBtdXN0JTIwYmUlMjBhJTIwbnVtYmVyJTIwZ3JlYXRlciUyMHRoYW4lMjAwAABBjgMLB3N0cmluZwAAQZYDCwdvYmplY3QA'].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
const y = s => typeof s == lS(0, 0) && s !== null, m = s => y(s) && !(s instanceof RegExp) && !(s instanceof Error) && !(s instanceof Date), S = Symbol(lS(0, 1)), p = (s, e, t, r = new WeakMap()) => {
        if (t = {
                deep: !1,
                target: {},
                ...t
            }, r.has(s))
            return r.get(s);
        (() => {
            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        r.set(s, t.target);
                    }
                }
            });
            const __exports = __callInstance2.exports;
            return __exports.data();
        })();
        const {target: i} = t;
        delete t.target;
        const a = n => n.map(o => m(o) ? p(o, e, t, r) : o);
        if (Array.isArray(s))
            return a(s);
        for (const [n, o] of Object.entries(s)) {
            const h = e(n, o, s);
            if (h === S)
                continue;
            let [l, c, {
                    shouldRecurse: f = !0
                } = {}] = h;
            l !== lS(0, 2) && (t.deep && f && m(c) && (c = Array.isArray(c) ? a(c) : p(c, e, t, r)), i[l] = c);
        }
        return i;
    };
function g(s, e, t) {
    if (!y(s))
        throw new TypeError(`Expected an object, got \`${ s }\` (${ typeof s })`);
    return p(s, e, t);
}
const R = /[\p{Lu}]/u, z = /[\p{Ll}]/u, x = /^[\p{Lu}](?![\p{Lu}])/gu, w = /([\p{Alpha}\p{N}_]|$)/u, _ = /[_.\- ]+/, L = new RegExp(lS(0, 3) + _.source), C = new RegExp(_.source + w.source, lS(0, 4)), A = new RegExp(lS(0, 5) + w.source, lS(0, 6)), T = (s, e, t, r) => {
        let i = !1, a = !1, n = !1, o = !1;
        (() => {
            let h = 0;
            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return h < s.length ? 1 : 0;
                    },
                    update: () => {
                        h++;
                    },
                    body: () => {
                        {
                            const l = s[h];
                            o = h > 2 ? s[h - 3] === lS(0, 7) : !0, i && R.test(l) ? (s = s.slice(0, h) + lS(0, 8) + s.slice(h), i = !1, n = a, a = !0, h++) : a && n && z.test(l) && (!o || r) ? (s = s.slice(0, h - 1) + lS(0, 9) + s.slice(h - 1), n = a, a = !1, i = !0) : (i = e(l) === l && t(l) !== l, n = a, a = t(l) === l && e(l) !== l);
                        }
                    }
                }
            });
            const __exports = __forInstance0.exports;
            return __exports.data();
        })();
        return s;
    }, b = (s, e) => (x.lastIndex = 0, s.replaceAll(x, t => e(t))), O = (s, e) => (C.lastIndex = 0, A.lastIndex = 0, s.replaceAll(A, (t, r, i) => [
        lS(0, 10),
        lS(0, 11)
    ].includes(s.charAt(i + t.length)) ? t : e(t)).replaceAll(C, (t, r) => e(r)));
function N(s, e) {
    if (!(typeof s == lS(0, 12) || Array.isArray(s)))
        throw new TypeError(lS(0, 13));
    if (e = {
            pascalCase: !1,
            preserveConsecutiveUppercase: !1,
            ...e
        }, Array.isArray(s) ? s = s.map(a => a.trim()).filter(a => a.length).join(lS(0, 14)) : s = s.trim(), s.length === 0)
        return lS(0, 15);
    const t = e.locale === !1 ? a => a.toLowerCase() : a => a.toLocaleLowerCase(e.locale), r = e.locale === !1 ? a => a.toUpperCase() : a => a.toLocaleUpperCase(e.locale);
    return s.length === 1 ? _.test(s) ? lS(0, 16) : e.pascalCase ? r(s) : t(s) : (s !== t(s) && (s = T(s, t, r, e.preserveConsecutiveUppercase)), s = s.replace(L, lS(0, 17)), s = e.preserveConsecutiveUppercase ? b(s, t) : t(s), e.pascalCase && (s = r(s.charAt(0)) + s.slice(1)), O(s, r));
}
class D extends Map {
    constructor(e = {}) {
        if (super(), !(e.maxSize && e.maxSize > 0))
            throw new TypeError(lS(0, 18));
        if (typeof e.maxAge == lS(0, 19) && e.maxAge === 0)
            throw new TypeError(lS(0, 20));
        this.maxSize = e.maxSize, this.maxAge = e.maxAge || Number.POSITIVE_INFINITY, this.onEviction = e.onEviction, this.cache = new Map(), this.oldCache = new Map(), this._size = 0;
    }
    _emitEvictions(e) {
        (() => {
            const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        for (const [t, r] of e)
                            (() => {
                                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            this.onEviction(t, r.value);
                                        }
                                    }
                                });
                                const __exports = __callInstance1.exports;
                                return __exports.data();
                            })();
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance0.exports;
            return __exports.data(typeof this.onEviction == lS(0, 21) ? 1 : 0);
        })();
    }
    _deleteIfExpired(e, t) {
        return typeof t.expiry == lS(0, 22) && t.expiry <= Date.now() ? (typeof this.onEviction == lS(0, 23) && this.onEviction(e, t.value), this.delete(e)) : !1;
    }
    _getOrDeleteIfExpired(e, t) {
        if (this._deleteIfExpired(e, t) === !1)
            return t.value;
    }
    _getItemValue(e, t) {
        return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value;
    }
    _peek(e, t) {
        const r = t.get(e);
        return this._getItemValue(e, r);
    }
    _set(e, t) {
        this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map());
    }
    _moveToRecent(e, t) {
        this.oldCache.delete(e), this._set(e, t);
    }
    *_entriesAscending() {
        for (const e of this.oldCache) {
            const [t, r] = e;
            this.cache.has(t) || this._deleteIfExpired(t, r) === !1 && (yield e);
        }
        for (const e of this.cache) {
            const [t, r] = e;
            this._deleteIfExpired(t, r) === !1 && (yield e);
        }
    }
    get(e) {
        if (this.cache.has(e)) {
            const t = this.cache.get(e);
            return this._getItemValue(e, t);
        }
        if (this.oldCache.has(e)) {
            const t = this.oldCache.get(e);
            if (this._deleteIfExpired(e, t) === !1)
                return this._moveToRecent(e, t), t.value;
        }
    }
    set(e, t, {
        maxAge: r = this.maxAge
    } = {}) {
        const i = typeof r == lS(0, 24) && r !== Number.POSITIVE_INFINITY ? Date.now() + r : void 0;
        return this.cache.has(e) ? this.cache.set(e, {
            value: t,
            expiry: i
        }) : this._set(e, {
            value: t,
            expiry: i
        }), this;
    }
    has(e) {
        return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
    }
    peek(e) {
        if (this.cache.has(e))
            return this._peek(e, this.cache);
        if (this.oldCache.has(e))
            return this._peek(e, this.oldCache);
    }
    delete(e) {
        const t = this.cache.delete(e);
        return t && this._size--, this.oldCache.delete(e) || t;
    }
    clear() {
        this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e) {
        if (!(e && e > 0))
            throw new TypeError(lS(0, 25));
        const t = [...this._entriesAscending()], r = t.length - e;
        r < 0 ? (this.cache = new Map(t), this.oldCache = new Map(), this._size = t.length) : (r > 0 && this._emitEvictions(t.slice(0, r)), this.oldCache = new Map(t.slice(r)), this.cache = new Map(), this._size = 0), this.maxSize = e;
    }
    *keys() {
        for (const [e] of this)
            yield e;
    }
    *values() {
        for (const [, e] of this)
            yield e;
    }
    *[Symbol.iterator]() {
        for (const e of this.cache) {
            const [t, r] = e;
            this._deleteIfExpired(t, r) === !1 && (yield [
                t,
                r.value
            ]);
        }
        for (const e of this.oldCache) {
            const [t, r] = e;
            this.cache.has(t) || this._deleteIfExpired(t, r) === !1 && (yield [
                t,
                r.value
            ]);
        }
    }
    *entriesDescending() {
        let e = [...this.cache];
        for (let t = e.length - 1; t >= 0; --t) {
            const r = e[t], [i, a] = r;
            this._deleteIfExpired(i, a) === !1 && (yield [
                i,
                a.value
            ]);
        }
        e = [...this.oldCache];
        for (let t = e.length - 1; t >= 0; --t) {
            const r = e[t], [i, a] = r;
            this.cache.has(i) || this._deleteIfExpired(i, a) === !1 && (yield [
                i,
                a.value
            ]);
        }
    }
    *entriesAscending() {
        for (const [e, t] of this._entriesAscending())
            yield [
                e,
                t.value
            ];
    }
    get size() {
        if (!this._size)
            return this.oldCache.size;
        let e = 0;
        for (const t of this.oldCache.keys())
            this.cache.has(t) || e++;
        return Math.min(this._size + e, this.maxSize);
    }
    entries() {
        return this.entriesAscending();
    }
    forEach(e, t = this) {
        for (const [r, i] of this.entriesAscending())
            (() => {
                const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            e.call(t, i, r, this);
                        }
                    }
                });
                const __exports = __callInstance0.exports;
                return __exports.data();
            })();
    }
    get [Symbol.toStringTag]() {
        return JSON.stringify([...this.entriesAscending()]);
    }
}
const U = (s, e) => s.some(t => typeof t == lS(0, 26) ? t === e : (t.lastIndex = 0, t.test(e))), u = new D({ maxSize: 100000 }), I = s => typeof s == lS(0, 27) && s !== null && !(s instanceof RegExp) && !(s instanceof Error) && !(s instanceof Date), v = (s, e = {}) => {
        if (!I(s))
            return s;
        const {
                exclude: t,
                pascalCase: r = !1,
                stopPaths: i,
                deep: a = !1,
                preserveConsecutiveUppercase: n = !1
            } = e, o = new Set(i), h = l => (c, f) => {
                (() => {
                    const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const d = l === void 0 ? c : `${ l }.${ c }`;
                                    o.has(d) || (f = g(f, h(d)));
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance1.exports;
                    return __exports.data(a && I(f) ? 1 : 0);
                })();
                (() => {
                    const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const d = r ? `${ c }_` : c;
                                    (() => {
                                        const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    c = u.get(d);
                                                },
                                                impFunc2: () => {
                                                    {
                                                        const E = N(c, {
                                                            pascalCase: r,
                                                            locale: !1,
                                                            preserveConsecutiveUppercase: n
                                                        });
                                                        c.length < 100 && u.set(d, E), c = E;
                                                    }
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance3.exports;
                                        return __exports.data(u.has(d) ? 1 : 0);
                                    })();
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance2.exports;
                    return __exports.data(!(t && U(t, c)) ? 1 : 0);
                })();
                return [
                    c,
                    f
                ];
            };
        return g(s, h(void 0));
    };
function M(s, e) {
    return Array.isArray(s) ? Object.keys(s).map(t => v(s[t], e)) : v(s, e);
}
export {
    M as c
};</script>
</body>
</html>
