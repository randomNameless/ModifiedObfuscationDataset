<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>firebase-messaging.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABCAJgAABgAAF/AiQDA2ppcARyYm14AAEDY3Z3Bmt2bXRtbQAAA2FndgRrd3hyAAADAgEABAUBcAAECQUDAQABBxECBm1lbW9yeQIABGJlanUAAwkKAQBBAQsEAAIDAQoeARwAAkADQEEBEQEARQ0BQQIRAABBBBEAAAwACwsL';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABCAJgAABgAX8AAh8CA3NyZghsbXhuY2xhdAAAA3pqaghvcHVjcmx6dQAAAwIBAQQFAXAAAwgFAwEAAQcRAgZtZW1vcnkCAARkeXBhAAIJCQEAQQELAwECAAoOAQwAIAAEQBAABRABCws=';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABBAFgAAACDwEDdGhyB292dmJkZ3IAAAMCAQAEBQFwAAIHBQMBAAEHEQIGbWVtb3J5AgAEam1hZQABCQgBAEEBCwIAAQoJAQcAQQERAAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG74iAgAC+AX8AQQELfwBBEAt/AEEYC38AQR4LfwBBJAt/AEE2C38AQT4LfwBBxAALfwBBzAALfwBB3gALfwBB6AALfwBB8gALfwBB+gALfwBBggELfwBBjgELfwBBmgELfwBBpAELfwBBrAELfwBBtAELfwBBvgELfwBBxgELfwBB0AELfwBB2AELfwBB6AELfwBB8gELfwBB+gELfwBBigILfwBBlAILfwBBmgILfwBBogILfwBBqgILfwBBtgILfwBBvgILfwBBxAILfwBBygILfwBB0gILfwBB2gILfwBB4gILfwBB5AILfwBB8AILfwBB+gILfwBBmAMLfwBBqAMLfwBBuAMLfwBByAMLfwBBzAMLfwBB0gMLfwBB4gMLfwBB8gMLfwBB9gMLfwBB+gMLfwBB/AMLfwBB/gMLfwBBkAQLfwBBsAQLfwBBzgQLfwBB8AQLfwBB/AQLfwBBiAULfwBBlAULfwBBogULfwBBtgULfwBBzgULfwBB0AULfwBB6AULfwBB/AULfwBBlgYLfwBBpgYLfwBBtAYLfwBBxAYLfwBB4AYLfwBB5gYLfwBB/AYLfwBBiAcLfwBBlAcLfwBBnAcLfwBBpAcLfwBBsAcLfwBBtgcLfwBBxgcLfwBB1gcLfwBB3gcLfwBB9gcLfwBBgAgLfwBBiAgLfwBBkAgLfwBBmggLfwBB9AgLfwBB9ggLfwBB+ggLfwBB/ggLfwBBhAkLfwBBigkLfwBBkAkLfwBBngkLfwBBtAkLfwBBxAkLfwBB2gkLfwBB9AkLfwBBkgoLfwBBngoLfwBBtAoLfwBBygoLfwBB4goLfwBB+goLfwBBiAsLfwBBkAsLfwBBpgsLfwBBvAsLfwBByAsLfwBB0AsLfwBB2AsLfwBB4AsLfwBB6AsLfwBB8AsLfwBB+AsLfwBBgAwLfwBBjAwLfwBBmAwLfwBBpAwLfwBBvgwLfwBB2AwLfwBB3gwLfwBB5gwLfwBB/AwLfwBBkg0LfwBBqg0LfwBBtg0LfwBBzg0LfwBB5g0LfwBBgA4LfwBBgg4LfwBBng4LfwBBxg4LfwBB8A4LfwBBhg8LfwBBnA8LfwBBug8LfwBBxg8LfwBB0g8LfwBB2g8LfwBB4g8LfwBB9g8LfwBBlBALfwBBuBALfwBB0hALfwBB3BALfwBB5hALfwBB+hALfwBBlBELfwBBqBELfwBBwhELfwBB1BELfwBB5BELfwBB9BELfwBBjhILfwBBlBILfwBBrBILfwBBwBILfwBByhILfwBB1BILfwBB3BILfwBB7hILfwBB8hILfwBBgBMLfwBBjBMLfwBBxhMLfwBByBMLfwBB1BMLfwBB3BMLfwBB6BMLfwBB+BMLfwBBhhQLfwBBlBQLfwBBnBQLfwBBrhQLfwBBthQLfwBBzBQLfwBB5BQLfwBB8BQLfwBBihULfwBBpBULfwBBsBULfwBBuBULfwBBzBULfwBB1hULfwBB4BULfwBB6hULfwBB9BULfwBB+hULB8eOgIAAvwEGbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgFZGF0YTkDCQZkYXRhMTADCgZkYXRhMTEDCwZkYXRhMTIDDAZkYXRhMTMDDQZkYXRhMTQDDgZkYXRhMTUDDwZkYXRhMTYDEAZkYXRhMTcDEQZkYXRhMTgDEgZkYXRhMTkDEwZkYXRhMjADFAZkYXRhMjEDFQZkYXRhMjIDFgZkYXRhMjMDFwZkYXRhMjQDGAZkYXRhMjUDGQZkYXRhMjYDGgZkYXRhMjcDGwZkYXRhMjgDHAZkYXRhMjkDHQZkYXRhMzADHgZkYXRhMzEDHwZkYXRhMzIDIAZkYXRhMzMDIQZkYXRhMzQDIgZkYXRhMzUDIwZkYXRhMzYDJAZkYXRhMzcDJQZkYXRhMzgDJgZkYXRhMzkDJwZkYXRhNDADKAZkYXRhNDEDKQZkYXRhNDIDKgZkYXRhNDMDKwZkYXRhNDQDLAZkYXRhNDUDLQZkYXRhNDYDLgZkYXRhNDcDLwZkYXRhNDgDMAZkYXRhNDkDMQZkYXRhNTADMgZkYXRhNTEDMwZkYXRhNTIDNAZkYXRhNTMDNQZkYXRhNTQDNgZkYXRhNTUDNwZkYXRhNTYDOAZkYXRhNTcDOQZkYXRhNTgDOgZkYXRhNTkDOwZkYXRhNjADPAZkYXRhNjEDPQZkYXRhNjIDPgZkYXRhNjMDPwZkYXRhNjQDQAZkYXRhNjUDQQZkYXRhNjYDQgZkYXRhNjcDQwZkYXRhNjgDRAZkYXRhNjkDRQZkYXRhNzADRgZkYXRhNzEDRwZkYXRhNzIDSAZkYXRhNzMDSQZkYXRhNzQDSgZkYXRhNzUDSwZkYXRhNzYDTAZkYXRhNzcDTQZkYXRhNzgDTgZkYXRhNzkDTwZkYXRhODADUAZkYXRhODEDUQZkYXRhODIDUgZkYXRhODMDUwZkYXRhODQDVAZkYXRhODUDVQZkYXRhODYDVgZkYXRhODcDVwZkYXRhODgDWAZkYXRhODkDWQZkYXRhOTADWgZkYXRhOTEDWwZkYXRhOTIDXAZkYXRhOTMDXQZkYXRhOTQDXgZkYXRhOTUDXwZkYXRhOTYDYAZkYXRhOTcDYQZkYXRhOTgDYgZkYXRhOTkDYwdkYXRhMTAwA2QHZGF0YTEwMQNlB2RhdGExMDIDZgdkYXRhMTAzA2cHZGF0YTEwNANoB2RhdGExMDUDaQdkYXRhMTA2A2oHZGF0YTEwNwNrB2RhdGExMDgDbAdkYXRhMTA5A20HZGF0YTExMANuB2RhdGExMTEDbwdkYXRhMTEyA3AHZGF0YTExMwNxB2RhdGExMTQDcgdkYXRhMTE1A3MHZGF0YTExNgN0B2RhdGExMTcDdQdkYXRhMTE4A3YHZGF0YTExOQN3B2RhdGExMjADeAdkYXRhMTIxA3kHZGF0YTEyMgN6B2RhdGExMjMDewdkYXRhMTI0A3wHZGF0YTEyNQN9B2RhdGExMjYDfgdkYXRhMTI3A38HZGF0YTEyOAOAAQdkYXRhMTI5A4EBB2RhdGExMzADggEHZGF0YTEzMQODAQdkYXRhMTMyA4QBB2RhdGExMzMDhQEHZGF0YTEzNAOGAQdkYXRhMTM1A4cBB2RhdGExMzYDiAEHZGF0YTEzNwOJAQdkYXRhMTM4A4oBB2RhdGExMzkDiwEHZGF0YTE0MAOMAQdkYXRhMTQxA40BB2RhdGExNDIDjgEHZGF0YTE0MwOPAQdkYXRhMTQ0A5ABB2RhdGExNDUDkQEHZGF0YTE0NgOSAQdkYXRhMTQ3A5MBB2RhdGExNDgDlAEHZGF0YTE0OQOVAQdkYXRhMTUwA5YBB2RhdGExNTEDlwEHZGF0YTE1MgOYAQdkYXRhMTUzA5kBB2RhdGExNTQDmgEHZGF0YTE1NQObAQdkYXRhMTU2A5wBB2RhdGExNTcDnQEHZGF0YTE1OAOeAQdkYXRhMTU5A58BB2RhdGExNjADoAEHZGF0YTE2MQOhAQdkYXRhMTYyA6IBB2RhdGExNjMDowEHZGF0YTE2NAOkAQdkYXRhMTY1A6UBB2RhdGExNjYDpgEHZGF0YTE2NwOnAQdkYXRhMTY4A6gBB2RhdGExNjkDqQEHZGF0YTE3MAOqAQdkYXRhMTcxA6sBB2RhdGExNzIDrAEHZGF0YTE3MwOtAQdkYXRhMTc0A64BB2RhdGExNzUDrwEHZGF0YTE3NgOwAQdkYXRhMTc3A7EBB2RhdGExNzgDsgEHZGF0YTE3OQOzAQdkYXRhMTgwA7QBB2RhdGExODEDtQEHZGF0YTE4MgO2AQdkYXRhMTgzA7cBB2RhdGExODQDuAEHZGF0YTE4NQO5AQdkYXRhMTg2A7oBB2RhdGExODcDuwEHZGF0YTE4OAO8AQdkYXRhMTg5A70BC8ecgIAAvgEAQQELDkZpcmViYXNlRXJyb3IAAEEQCwZFcnJvcgAAQRgLBUxBWlkAAEEeCwVkb25lAABBJAsRb2JqZWN0U3RvcmVOYW1lcwAAQTYLBnN0b3JlAABBPgsFZG9uZQAAQcQACwZzdG9yZQAAQcwACxFvYmplY3RTdG9yZU5hbWVzAABB3gALCWZ1bmN0aW9uAABB6AALCWNvbXBsZXRlAABB8gALBmVycm9yAABB+gALBmFib3J0AABBggELC0Fib3J0RXJyb3IAAEGOAQsLQWJvcnRFcnJvcgAAQZoBCwljb21wbGV0ZQAAQaQBCwZlcnJvcgAAQawBCwZhYm9ydAAAQbQBCwhzdWNjZXNzAABBvgELBmVycm9yAABBxgELCHN1Y2Nlc3MAAEHQAQsGZXJyb3IAAEHYAQsOdXBncmFkZW5lZWRlZAAAQegBCwhibG9ja2VkAABB8gELBmNsb3NlAABB+gELDnZlcnNpb25jaGFuZ2UAAEGKAgsIYmxvY2tlZAAAQZQCCwRnZXQAAEGaAgsHZ2V0S2V5AABBogILB2dldEFsbAAAQaoCCwtnZXRBbGxLZXlzAABBtgILBmNvdW50AABBvgILBHB1dAAAQcQCCwRhZGQAAEHKAgsHZGVsZXRlAABB0gILBmNsZWFyAABB2gILB3N0cmluZwAAQeICCwEAAEHkAgsKcmVhZHdyaXRlAABB8AILCXJlYWRvbmx5AABB+gILHCU0MGZpcmViYXNlJTJGaW5zdGFsbGF0aW9ucwAAQZgDCw5pbnN0YWxsYXRpb25zAABBqAMLDkluc3RhbGxhdGlvbnMAAEG4AwsPcmVxdWVzdC1mYWlsZWQAAEHIAwsCcwAAQcwDCwQwMDAAAEHSAwsPcmVxdWVzdC1mYWlsZWQAAEHiAwsOQXV0aG9yaXphdGlvbgAAQfIDCwItAABB9gMLAl8AAEH6AwsBAABB/AMLAQAAQf4DCxFCcm9hZGNhc3RDaGFubmVsAABBkAQLHiU1QkZpcmViYXNlJTVEJTIwRklEJTIwQ2hhbmdlAABBsAQLHWZpcmViYXNlLWluc3RhbGxhdGlvbnMtc3RvcmUAAEHOBAsgZmlyZWJhc2UtaW5zdGFsbGF0aW9ucy1kYXRhYmFzZQAAQfAECwpyZWFkd3JpdGUAAEH8BAsKcmVhZHdyaXRlAABBiAULCnJlYWR3cml0ZQAAQZQFCwxhcHAtb2ZmbGluZQAAQaIFCxJ4LWZpcmViYXNlLWNsaWVudAAAQbYFCxZDcmVhdGUlMjBJbnN0YWxsYXRpb24AAEHOBQsBAABB0AULF2luc3RhbGxhdGlvbi1ub3QtZm91bmQAAEHoBQsSeC1maXJlYmFzZS1jbGllbnQAAEH8BQsYR2VuZXJhdGUlMjBBdXRoJTIwVG9rZW4AAEGWBgsPbm90LXJlZ2lzdGVyZWQAAEGmBgsMYXBwLW9mZmxpbmUAAEG0BgsPbm90LXJlZ2lzdGVyZWQAAEHEBgsabWlzc2luZy1hcHAtY29uZmlnLXZhbHVlcwAAQeAGCwRhcHAAAEHmBgsUQXBwJTIwQ29uZmlndXJhdGlvbgAAQfwGCwtBcHAlMjBOYW1lAABBiAcLCnByb2plY3RJZAAAQZQHCwdhcGlLZXkAAEGcBwsGYXBwSWQAAEGkBwsKaGVhcnRiZWF0AABBsAcLBGFwcAAAQbYHCw5pbnN0YWxsYXRpb25zAABBxgcLDmluc3RhbGxhdGlvbnMAAEHWBwsHUFVCTElDAABB3gcLF2luc3RhbGxhdGlvbnMtaW50ZXJuYWwAAEH2BwsIUFJJVkFURQAAQYAICwYwLjYuOAAAQYgICwYwLjYuOAAAQZAICwhlc20yMDE3AABBmggLWEJET1U5OS1oNjdIY0E2SmVGWEhiU05NdTdlMnlOTnUzUnpvTWo4VE00Vzg4aklUZnE3Wm1QdklNMUl2LTRfbDJMeFFjWXdocWJ5MnhHcFd3empmQW5HNAAAQfQICwEAAEH2CAsCLQAAQfoICwJfAABB/ggLBCUzRAAAQYQJCwQlMkIAAEGKCQsEJTJGAABBkAkLDURBVEFfTUVTU0FHRQAAQZ4JCxVESVNQTEFZX05PVElGSUNBVElPTgAAQbQJCw5wdXNoLXJlY2VpdmVkAABBxAkLFW5vdGlmaWNhdGlvbi1jbGlja2VkAABB2gkLGWZpcmViYXNlLW1lc3NhZ2luZy1zdG9yZQAAQfQJCxxmaXJlYmFzZS1tZXNzYWdpbmctZGF0YWJhc2UAAEGSCgsKZGF0YWJhc2VzAABBngoLFWZjbV90b2tlbl9kZXRhaWxzX2RiAABBtAoLFWZjbV90b2tlbl9kZXRhaWxzX2RiAABBygoLF2ZjbV90b2tlbl9vYmplY3RfU3RvcmUAAEHiCgsXZmNtX3Rva2VuX29iamVjdF9TdG9yZQAAQfoKCwxmY21TZW5kZXJJZAAAQYgLCwdzdHJpbmcAAEGQCwsVZmNtX3Rva2VuX2RldGFpbHNfZGIAAEGmCwsVZmNtX3ZhcGlkX2RldGFpbHNfZGIAAEG8CwsKdW5kZWZpbmVkAABByAsLB251bWJlcgAAQdALCwdzdHJpbmcAAEHYCwsHc3RyaW5nAABB4AsLB3N0cmluZwAAQegLCwdzdHJpbmcAAEHwCwsHc3RyaW5nAABB+AsLB3N0cmluZwAAQYAMCwpyZWFkd3JpdGUAAEGMDAsKbWVzc2FnaW5nAABBmAwLCk1lc3NhZ2luZwAAQaQMCxl0b2tlbi11bnN1YnNjcmliZS1mYWlsZWQAAEG+DAsZdG9rZW4tdW5zdWJzY3JpYmUtZmFpbGVkAABB2AwLBWF1dGgAAEHeDAsHcDI1NmRoAABB5gwLFHRva2VuLXVwZGF0ZS1mYWlsZWQAAEH8DAsUdG9rZW4tdXBkYXRlLWZhaWxlZAAAQZINCxZ0b2tlbi11cGRhdGUtbm8tdG9rZW4AAEGqDQsKcmVhZHdyaXRlAABBtg0LF3Rva2VuLXN1YnNjcmliZS1mYWlsZWQAAEHODQsXdG9rZW4tc3Vic2NyaWJlLWZhaWxlZAAAQeYNCxl0b2tlbi1zdWJzY3JpYmUtbm8tdG9rZW4AAEGADgsBAABBgg4LGm1pc3NpbmctYXBwLWNvbmZpZy12YWx1ZXMAAEGeDgsnaHRzJTJGZnJic2xnaWdwLm9nZXBzY212JTJGaWVvJTJGZWF5bGcAAEHGDgsodHAlM0ElMkZpZWFlb2duLWFnb2xhaS5vJTJGMWZybGdsZ2MlMkZvAABB8A4LFUF6U0NidzYzZzFSMG5Ddzg1akc4AABBhg8LFElheWEzeUxLd21ndmg3Y0YwcTQAAEGcDwsdQXBwJTIwQ29uZmlndXJhdGlvbiUyME9iamVjdAAAQboPCwtBcHAlMjBOYW1lAABBxg8LCnByb2plY3RJZAAAQdIPCwdhcGlLZXkAAEHaDwsGYXBwSWQAAEHiDwsSbWVzc2FnaW5nU2VuZGVySWQAAEH2DwscJTJGZmlyZWJhc2UtbWVzc2FnaW5nLXN3LmpzAABBlBALI2ZhaWxlZC1zZXJ2aWNlLXdvcmtlci1yZWdpc3RyYXRpb24AAEG4EAsZb25seS1hdmFpbGFibGUtaW4td2luZG93AABB0hALCGRlZmF1bHQAAEHcEAsIZ3JhbnRlZAAAQeYQCxNwZXJtaXNzaW9uLWJsb2NrZWQAAEH6EAsYaW52YWxpZC1zdy1yZWdpc3RyYXRpb24AAEGUEQsSbm90aWZpY2F0aW9uX29wZW4AAEGoEQsYbm90aWZpY2F0aW9uX2ZvcmVncm91bmQAAEHCEQsQZ29vZ2xlLmMuYS5jX2lkAABB1BELD2dvb2dsZS5jLmEuY19sAABB5BELDmdvb2dsZS5jLmEudHMAAEH0EQsYJTQwZmlyZWJhc2UlMkZtZXNzYWdpbmcAAEGOEgsEYXBwAABBlBILF2luc3RhbGxhdGlvbnMtaW50ZXJuYWwAAEGsEgsTYW5hbHl0aWNzLWludGVybmFsAABBwBILCG1lc3NhZ2UAAEHKEgsJZnVuY3Rpb24AAEHUEgsHb2JqZWN0AABB3BILEGdvb2dsZS5jLmEuY19pZAAAQe4SCwIxAABB8hILDWdvb2dsZS5jLmEuZQAAQYATCwptZXNzYWdpbmcAAEGMEws4dmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZQAAQcYTCwEAAEHIEwsKdW5kZWZpbmVkAABB1BMLB29iamVjdAAAQdwTCwp1bmRlZmluZWQAAEHoEwsOc2VydmljZVdvcmtlcgAAQfgTCwxQdXNoTWFuYWdlcgAAQYYUCw1Ob3RpZmljYXRpb24AAEGUFAsGZmV0Y2gAAEGcFAsRc2hvd05vdGlmaWNhdGlvbgAAQa4UCwdnZXRLZXkAAEG2FAsUdW5zdXBwb3J0ZWQtYnJvd3NlcgAAQcwUCxdpbmRleGVkLWRiLXVuc3VwcG9ydGVkAABB5BQLCm1lc3NhZ2luZwAAQfAUCxlvbmx5LWF2YWlsYWJsZS1pbi13aW5kb3cAAEGKFQsZb25seS1hdmFpbGFibGUtaW4td2luZG93AABBpBULCm1lc3NhZ2luZwAAQbAVCwdQVUJMSUMAAEG4FQsTbWVzc2FnaW5nLWludGVybmFsAABBzBULCFBSSVZBVEUAAEHWFQsIMC4xMi4xMAAAQeAVCwgwLjEyLjEwAABB6hULCGVzbTIwMTcAAEH0FQsFYnRvYQAAQfoVCwVhdG9iAA=='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
import {
    registerVersion as e,
    _registerComponent as t,
    _getProvider,
    getApp as n
} from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js';
class FirebaseError extends Error {
    constructor(e, t, n) {
        super(t), this.code = e, this.customData = n, this.name = lS(0, 0), Object.setPrototypeOf(this, FirebaseError.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
}
class ErrorFactory {
    constructor(e, t, n) {
        this.service = e, this.serviceName = t, this.errors = n;
    }
    create(e, ...t) {
        const n = t[0] || {}, a = `${ this.service }/${ e }`, o = this.errors[e], i = o ? function replaceTemplate(e, t) {
                return e.replace(r, (e, n) => {
                    const r = t[n];
                    return null != r ? String(r) : `<${ n }?>`;
                });
            }(o, n) : lS(0, 1), s = `${ this.serviceName }: ${ i } (${ a }).`;
        return new FirebaseError(a, s, n);
    }
}
const r = /\{\$([^}]+)}/g;
function getModularInstance(e) {
    return e && e._delegate ? e._delegate : e;
}
class Component {
    constructor(e, t, n) {
        this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = lS(0, 2), this.onInstanceCreated = null;
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e, this;
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e, this;
    }
    setServiceProps(e) {
        return this.serviceProps = e, this;
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this;
    }
}
let a, o;
const i = new WeakMap(), s = new WeakMap(), c = new WeakMap(), u = new WeakMap(), d = new WeakMap();
let p = {
    get(e, t, n) {
        if (e instanceof IDBTransaction) {
            if (lS(0, 3) === t)
                return s.get(e);
            if (lS(0, 4) === t)
                return e.objectStoreNames || c.get(e);
            if (lS(0, 5) === t)
                return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
        }
        return wrap(e[t]);
    },
    set: (e, t, n) => (e[t] = n, !0),
    has: (e, t) => e instanceof IDBTransaction && (lS(0, 6) === t || lS(0, 7) === t) || t in e
};
function wrapFunction(e) {
    return e !== IDBDatabase.prototype.transaction || lS(0, 8) in IDBTransaction.prototype ? function getCursorAdvanceMethods() {
        return o || (o = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey
        ]);
    }().includes(e) ? function (...t) {
        return e.apply(unwrap(this), t), wrap(i.get(this));
    } : function (...t) {
        return wrap(e.apply(unwrap(this), t));
    } : function (t, ...n) {
        const r = e.call(unwrap(this), t, ...n);
        return c.set(r, t.sort ? t.sort() : [t]), wrap(r);
    };
}
function transformCachableValue(e) {
    return lS(0, 9) == typeof e ? wrapFunction(e) : (e instanceof IDBTransaction && function cacheDonePromiseForTransaction(e) {
        if (s.has(e))
            return;
        const t = new Promise((t, n) => {
            const unlisten = () => {
                    e.removeEventListener(lS(0, 10), complete), e.removeEventListener(lS(0, 11), error), e.removeEventListener(lS(0, 12), error);
                }, complete = () => {
                    t(), unlisten();
                }, error = () => {
                    n(e.error || new DOMException(lS(0, 13), lS(0, 14))), unlisten();
                };
            e.addEventListener(lS(0, 15), complete), e.addEventListener(lS(0, 16), error), e.addEventListener(lS(0, 17), error);
        });
        (() => {
            const __callInstance10 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        s.set(e, t);
                    }
                }
            });
            const __exports = __callInstance10.exports;
            return __exports.data();
        })();
    }(e), t = e, function getIdbProxyableTypes() {
        return a || (a = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction
        ]);
    }().some(e => t instanceof e) ? new Proxy(e, p) : e);
    var t;
}
function wrap(e) {
    if (e instanceof IDBRequest)
        return function promisifyRequest(e) {
            const t = new Promise((t, n) => {
                const unlisten = () => {
                        e.removeEventListener(lS(0, 18), success), e.removeEventListener(lS(0, 19), error);
                    }, success = () => {
                        t(wrap(e.result)), unlisten();
                    }, error = () => {
                        n(e.error), unlisten();
                    };
                e.addEventListener(lS(0, 20), success), e.addEventListener(lS(0, 21), error);
            });
            return t.then(t => {
                t instanceof IDBCursor && i.set(t, e);
            }).catch(() => {
            }), d.set(t, e), t;
        }(e);
    if (u.has(e))
        return u.get(e);
    const t = transformCachableValue(e);
    return t !== e && (u.set(e, t), d.set(t, e)), t;
}
const unwrap = e => d.get(e);
function openDB(e, t, {
    blocked: n,
    upgrade: r,
    blocking: a,
    terminated: o
} = {}) {
    const i = indexedDB.open(e, t), s = wrap(i);
    return r && i.addEventListener(lS(0, 22), e => {
        (() => {
            const __callInstance9 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        r(wrap(i.result), e.oldVersion, e.newVersion, wrap(i.transaction), e);
                    }
                }
            });
            const __exports = __callInstance9.exports;
            return __exports.data();
        })();
    }), n && i.addEventListener(lS(0, 23), e => n(e.oldVersion, e.newVersion, e)), s.then(e => {
        o && e.addEventListener(lS(0, 24), () => o()), a && e.addEventListener(lS(0, 25), e => a(e.oldVersion, e.newVersion, e));
    }).catch(() => {
    }), s;
}
function deleteDB(e, {blocked: t} = {}) {
    const n = indexedDB.deleteDatabase(e);
    return t && n.addEventListener(lS(0, 26), e => t(e.oldVersion, e)), wrap(n).then(() => {
    });
}
const l = [
        lS(0, 27),
        lS(0, 28),
        lS(0, 29),
        lS(0, 30),
        lS(0, 31)
    ], g = [
        lS(0, 32),
        lS(0, 33),
        lS(0, 34),
        lS(0, 35)
    ], f = new Map();
function getMethod(e, t) {
    if (!(e instanceof IDBDatabase) || t in e || lS(0, 36) != typeof t)
        return;
    if (f.get(t))
        return f.get(t);
    const n = t.replace(/FromIndex$/, lS(0, 37)), r = t !== n, a = g.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !a && !l.includes(n))
        return;
    const method = async function (e, ...t) {
        const o = this.transaction(e, a ? lS(0, 38) : lS(0, 39));
        let i = o.store;
        return r && (i = i.index(t.shift())), (await Promise.all([
            i[n](...t),
            a && o.done
        ]))[0];
    };
    return f.set(t, method), method;
}
!function replaceTraps(e) {
    p = e(p);
}(e => ({
    ...e,
    get: (t, n, r) => getMethod(t, n) || e.get(t, n, r),
    has: (t, n) => !!getMethod(t, n) || e.has(t, n)
}));
const h = lS(0, 40), w = new ErrorFactory(lS(0, 41), lS(0, 42), {
        'missing-app-config-values': 'Missing App configuration value: "{$valueName}"',
        'not-registered': 'Firebase Installation is not registered.',
        'installation-not-found': 'Firebase Installation not found.',
        'request-failed': '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
        'app-offline': 'Could not process request. Application offline.',
        'delete-pending-registration': 'Can\'t delete installation while there is a pending registration request.'
    });
function isServerError(e) {
    return e instanceof FirebaseError && e.code.includes(lS(0, 43));
}
function getInstallationsEndpoint({projectId: e}) {
    return `https://firebaseinstallations.googleapis.com/v1/projects/${ e }/installations`;
}
function extractAuthTokenInfoFromResponse(e) {
    return {
        token: e.token,
        requestStatus: 2,
        expiresIn: (t = e.expiresIn, Number(t.replace(lS(0, 44), lS(0, 45)))),
        creationTime: Date.now()
    };
    var t;
}
async function getErrorFromResponse(e, t) {
    const n = (await t.json()).error;
    return w.create(lS(0, 46), {
        requestName: e,
        serverCode: n.code,
        serverMessage: n.message,
        serverStatus: n.status
    });
}
function getHeaders$1({apiKey: e}) {
    return new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'x-goog-api-key': e
    });
}
function getHeadersWithAuth(e, {refreshToken: t}) {
    const n = getHeaders$1(e);
    return n.append(lS(0, 47), function getAuthorizationHeader(e) {
        return `FIS_v2 ${ e }`;
    }(t)), n;
}
async function retryIfServerError(e) {
    const t = await e();
    return t.status >= 500 && t.status < 600 ? e() : t;
}
function sleep(e) {
    return new Promise(t => {
        (() => {
            const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        setTimeout(t, e);
                    }
                }
            });
            const __exports = __callInstance8.exports;
            return __exports.data();
        })();
    });
}
const m = /^[cdef][\w-]{21}$/;
function generateFid() {
    try {
        const e = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16;
        const t = function encode(e) {
            return function bufferToBase64UrlSafe(e) {
                return window[lS(0, 188, true)](String.fromCharCode(...e)).replace(/\+/g, lS(0, 48)).replace(/\//g, lS(0, 49));
            }(e).substr(0, 22);
        }(e);
        return m.test(t) ? t : lS(0, 50);
    } catch (e) {
        return lS(0, 51);
    }
}
function getKey$1(e) {
    return `${ e.appName }!${ e.appId }`;
}
const y = new Map();
function fidChanged(e, t) {
    const n = getKey$1(e);
    callFidChangeCallbacks(n, t), function broadcastFidChange(e, t) {
        const n = function getBroadcastChannel() {
            !b && lS(0, 52) in self && (b = new BroadcastChannel(lS(0, 53)), b.onmessage = e => {
                (() => {
                    const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                callFidChangeCallbacks(e.data.key, e.data.fid);
                            }
                        }
                    });
                    const __exports = __callInstance7.exports;
                    return __exports.data();
                })();
            });
            return b;
        }();
        n && n.postMessage({
            key: e,
            fid: t
        });
        !function closeBroadcastChannel() {
            0 === y.size && b && (b.close(), b = null);
        }();
    }(n, t);
}
function callFidChangeCallbacks(e, t) {
    const n = y.get(e);
    (() => {
        const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    for (const e of n)
                        (() => {
                            const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        e(t);
                                    }
                                }
                            });
                            const __exports = __callInstance6.exports;
                            return __exports.data();
                        })();
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance0.exports;
        return __exports.data(n ? 1 : 0);
    })();
}
let b = null;
const v = lS(0, 54);
let k = null;
function getDbPromise$1() {
    return k || (k = openDB(lS(0, 55), 1, {
        upgrade: (e, t) => {
            (() => {
                const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            e.createObjectStore(v);
                                        }
                                    }
                                });
                                const __exports = __callInstance5.exports;
                                return __exports.data();
                            })();
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance1.exports;
                return __exports.data(0 === t ? 1 : 0);
            })();
        }
    })), k;
}
async function set(e, t) {
    const n = getKey$1(e), r = (await getDbPromise$1()).transaction(v, lS(0, 56)), a = r.objectStore(v), o = await a.get(n);
    return await a.put(t, n), await r.done, o && o.fid === t.fid || fidChanged(e, t.fid), t;
}
async function remove(e) {
    const t = getKey$1(e), n = (await getDbPromise$1()).transaction(v, lS(0, 57));
    await n.objectStore(v).delete(t), await n.done;
}
async function update(e, t) {
    const n = getKey$1(e), r = (await getDbPromise$1()).transaction(v, lS(0, 58)), a = r.objectStore(v), o = await a.get(n), i = t(o);
    return void 0 === i ? await a.delete(n) : await a.put(i, n), await r.done, !i || o && o.fid === i.fid || fidChanged(e, i.fid), i;
}
async function getInstallationEntry(e) {
    let t;
    const n = await update(e.appConfig, n => {
        const r = function updateOrCreateInstallationEntry(e) {
                return clearTimedOutRequest(e || {
                    fid: generateFid(),
                    registrationStatus: 0
                });
            }(n), a = function triggerRegistrationIfNecessary(e, t) {
                if (0 === t.registrationStatus) {
                    if (!navigator.onLine) {
                        return {
                            installationEntry: t,
                            registrationPromise: Promise.reject(w.create(lS(0, 59)))
                        };
                    }
                    const n = {
                            fid: t.fid,
                            registrationStatus: 1,
                            registrationTime: Date.now()
                        }, r = async function registerInstallation(e, t) {
                            try {
                                const n = await async function createInstallationRequest({
                                    appConfig: e,
                                    heartbeatServiceProvider: t
                                }, {fid: n}) {
                                    const r = getInstallationsEndpoint(e), a = getHeaders$1(e), o = t.getImmediate({ optional: !0 });
                                    (() => {
                                        const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        const e = await o.getHeartbeatsHeader();
                                                        e && a.append(lS(0, 60), e);
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance2.exports;
                                        return __exports.data(o ? 1 : 0);
                                    })();
                                    const i = {
                                            fid: n,
                                            authVersion: 'FIS_v2',
                                            appId: e.appId,
                                            sdkVersion: 'w:0.6.8'
                                        }, s = {
                                            method: 'POST',
                                            headers: a,
                                            body: JSON.stringify(i)
                                        }, c = await retryIfServerError(() => fetch(r, s));
                                    if (c.ok) {
                                        const e = await c.json();
                                        return {
                                            fid: e.fid || n,
                                            registrationStatus: 2,
                                            refreshToken: e.refreshToken,
                                            authToken: extractAuthTokenInfoFromResponse(e.authToken)
                                        };
                                    }
                                    throw await getErrorFromResponse(lS(0, 61), c);
                                }(e, t);
                                return set(e.appConfig, n);
                            } catch (n) {
                                throw isServerError(n) && 409 === n.customData.serverCode ? await remove(e.appConfig) : await set(e.appConfig, {
                                    fid: t.fid,
                                    registrationStatus: 0
                                }), n;
                            }
                        }(e, n);
                    return {
                        installationEntry: n,
                        registrationPromise: r
                    };
                }
                return 1 === t.registrationStatus ? {
                    installationEntry: t,
                    registrationPromise: waitUntilFidRegistration(e)
                } : { installationEntry: t };
            }(e, r);
        return t = a.registrationPromise, a.installationEntry;
    });
    return lS(0, 62) === n.fid ? { installationEntry: await t } : {
        installationEntry: n,
        registrationPromise: t
    };
}
async function waitUntilFidRegistration(e) {
    let t = await updateInstallationRequest(e.appConfig);
    (() => {
        const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return 1 === t.registrationStatus ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    await sleep(100), t = await updateInstallationRequest(e.appConfig);
                }
            }
        });
        const __exports = __forInstance0.exports;
        return __exports.data();
    })();
    if (0 === t.registrationStatus) {
        const {
            installationEntry: t,
            registrationPromise: n
        } = await getInstallationEntry(e);
        return n || t;
    }
    return t;
}
function updateInstallationRequest(e) {
    return update(e, e => {
        if (!e)
            throw w.create(lS(0, 63));
        return clearTimedOutRequest(e);
    });
}
function clearTimedOutRequest(e) {
    return function hasInstallationRequestTimedOut(e) {
        return 1 === e.registrationStatus && e.registrationTime + 10000 < Date.now();
    }(e) ? {
        fid: e.fid,
        registrationStatus: 0
    } : e;
}
async function generateAuthTokenRequest({
    appConfig: e,
    heartbeatServiceProvider: t
}, n) {
    const r = function getGenerateAuthTokenEndpoint(e, {fid: t}) {
            return `${ getInstallationsEndpoint(e) }/${ t }/authTokens:generate`;
        }(e, n), a = getHeadersWithAuth(e, n), o = t.getImmediate({ optional: !0 });
    (() => {
        const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        const e = await o.getHeartbeatsHeader();
                        e && a.append(lS(0, 64), e);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance3.exports;
        return __exports.data(o ? 1 : 0);
    })();
    const i = {
            installation: {
                sdkVersion: 'w:0.6.8',
                appId: e.appId
            }
        }, s = {
            method: 'POST',
            headers: a,
            body: JSON.stringify(i)
        }, c = await retryIfServerError(() => fetch(r, s));
    if (c.ok) {
        return extractAuthTokenInfoFromResponse(await c.json());
    }
    throw await getErrorFromResponse(lS(0, 65), c);
}
async function refreshAuthToken(e, t = !1) {
    let n;
    const r = await update(e.appConfig, r => {
        if (!isEntryRegistered(r))
            throw w.create(lS(0, 66));
        const a = r.authToken;
        if (!t && function isAuthTokenValid(e) {
                return 2 === e.requestStatus && !function isAuthTokenExpired(e) {
                    const t = Date.now();
                    return t < e.creationTime || e.creationTime + e.expiresIn < t + 3600000;
                }(e);
            }(a))
            return r;
        if (1 === a.requestStatus)
            return n = async function waitUntilAuthTokenRequest(e, t) {
                let n = await updateAuthTokenRequest(e.appConfig);
                (() => {
                    const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return 1 === n.authToken.requestStatus ? 1 : 0;
                            },
                            update: () => {
                            },
                            body: () => {
                                await sleep(100), n = await updateAuthTokenRequest(e.appConfig);
                            }
                        }
                    });
                    const __exports = __forInstance1.exports;
                    return __exports.data();
                })();
                const r = n.authToken;
                return 0 === r.requestStatus ? refreshAuthToken(e, t) : r;
            }(e, t), r;
        {
            if (!navigator.onLine)
                throw w.create(lS(0, 67));
            const t = function makeAuthTokenRequestInProgressEntry(e) {
                const t = {
                    requestStatus: 1,
                    requestTime: Date.now()
                };
                return Object.assign(Object.assign({}, e), { authToken: t });
            }(r);
            return n = async function fetchAuthTokenFromServer(e, t) {
                try {
                    const n = await generateAuthTokenRequest(e, t), r = Object.assign(Object.assign({}, t), { authToken: n });
                    return await set(e.appConfig, r), n;
                } catch (n) {
                    (() => {
                        const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                            env: {
                                impFunc1: () => {
                                    {
                                        const n = Object.assign(Object.assign({}, t), { authToken: { requestStatus: 0 } });
                                        await set(e.appConfig, n);
                                    }
                                },
                                impFunc2: () => {
                                    await remove(e.appConfig);
                                }
                            }
                        });
                        const __exports = __ifInstance4.exports;
                        return __exports.data(!isServerError(n) || 401 !== n.customData.serverCode && 404 !== n.customData.serverCode ? 1 : 0);
                    })();
                    throw n;
                }
            }(e, t), t;
        }
    });
    return n ? await n : r.authToken;
}
function updateAuthTokenRequest(e) {
    return update(e, e => {
        if (!isEntryRegistered(e))
            throw w.create(lS(0, 68));
        return function hasAuthTokenRequestTimedOut(e) {
            return 1 === e.requestStatus && e.requestTime + 10000 < Date.now();
        }(e.authToken) ? Object.assign(Object.assign({}, e), { authToken: { requestStatus: 0 } }) : e;
    });
}
function isEntryRegistered(e) {
    return void 0 !== e && 2 === e.registrationStatus;
}
async function getToken$2(e, t = !1) {
    const n = e;
    await async function completeInstallationRegistration(e) {
        const {registrationPromise: t} = await getInstallationEntry(e);
        t && await t;
    }(n);
    return (await refreshAuthToken(n, t)).token;
}
function getMissingValueError$1(e) {
    return w.create(lS(0, 69), { valueName: e });
}
const publicFactory = e => {
        const t = e.getProvider(lS(0, 70)).getImmediate(), n = function extractAppConfig$1(e) {
                if (!e || !e.options)
                    throw getMissingValueError$1(lS(0, 71));
                if (!e.name)
                    throw getMissingValueError$1(lS(0, 72));
                const t = [
                    lS(0, 73),
                    lS(0, 74),
                    lS(0, 75)
                ];
                for (const n of t)
                    if (!e.options[n])
                        throw getMissingValueError$1(n);
                return {
                    appName: e.name,
                    projectId: e.options.projectId,
                    apiKey: e.options.apiKey,
                    appId: e.options.appId
                };
            }(t);
        return {
            app: t,
            appConfig: n,
            heartbeatServiceProvider: _getProvider(t, lS(0, 76)),
            _delete: () => Promise.resolve()
        };
    }, internalFactory = e => {
        const t = e.getProvider(lS(0, 77)).getImmediate(), n = _getProvider(t, lS(0, 78)).getImmediate();
        return {
            getId: () => async function getId(e) {
                const t = e, {
                        installationEntry: n,
                        registrationPromise: r
                    } = await getInstallationEntry(t);
                return r ? r.catch(console.error) : refreshAuthToken(t).catch(console.error), n.fid;
            }(n),
            getToken: e => getToken$2(n, e)
        };
    };
!function registerInstallations() {
    t(new Component(lS(0, 79), publicFactory, lS(0, 80))), t(new Component(lS(0, 81), internalFactory, lS(0, 82)));
}(), e(h, lS(0, 83)), e(h, lS(0, 84), lS(0, 85));
const I = lS(0, 86);
var T, S;
function arrayToBase64(e) {
    const t = new Uint8Array(e);
    return window[lS(0, 188, true)](String.fromCharCode(...t)).replace(/=/g, lS(0, 87)).replace(/\+/g, lS(0, 88)).replace(/\//g, lS(0, 89));
}
function base64ToArray(e) {
    const t = (e + lS(0, 90).repeat((4 - e.length % 4) % 4)).replace(/\-/g, lS(0, 91)).replace(/_/g, lS(0, 92)), n = window[lS(0, 189, true)](t), r = new Uint8Array(n.length);
    (() => {
        let e = 0;
        const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return e < n.length ? 1 : 0;
                },
                update: () => {
                    ++e;
                },
                body: () => {
                    r[e] = n.charCodeAt(e);
                }
            }
        });
        const __exports = __forInstance2.exports;
        return __exports.data();
    })();
    return r;
}
!function (e) {
    e[e.DATA_MESSAGE = 1] = lS(0, 93), e[e.DISPLAY_NOTIFICATION = 3] = lS(0, 94);
}(T || (T = {})), function (e) {
    e.PUSH_RECEIVED = lS(0, 95), e.NOTIFICATION_CLICKED = lS(0, 96);
}(S || (S = {}));
const E = lS(0, 97);
let D = null;
function getDbPromise() {
    return D || (D = openDB(lS(0, 98), 1, {
        upgrade: (e, t) => {
            (() => {
                const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            e.createObjectStore(E);
                                        }
                                    }
                                });
                                const __exports = __callInstance4.exports;
                                return __exports.data();
                            })();
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance5.exports;
                return __exports.data(0 === t ? 1 : 0);
            })();
        }
    })), D;
}
async function dbGet(e) {
    const t = getKey(e), n = await getDbPromise(), r = await n.transaction(E).objectStore(E).get(t);
    if (r)
        return r;
    {
        const t = await async function migrateOldDatabase(e) {
            if (lS(0, 99) in indexedDB) {
                const e = (await indexedDB.databases()).map(e => e.name);
                if (!e.includes(lS(0, 100)))
                    return null;
            }
            let t = null;
            return (await openDB(lS(0, 101), 5, {
                upgrade: async (n, r, a, o) => {
                    var i;
                    if (r < 2)
                        return;
                    if (!n.objectStoreNames.contains(lS(0, 102)))
                        return;
                    const s = o.objectStore(lS(0, 103)), c = await s.index(lS(0, 104)).get(e);
                    if (await s.clear(), c)
                        if (2 === r) {
                            const e = c;
                            if (!e.auth || !e.p256dh || !e.endpoint)
                                return;
                            t = {
                                token: e.fcmToken,
                                createTime: null !== (i = e.createTime) && void 0 !== i ? i : Date.now(),
                                subscriptionOptions: {
                                    auth: e.auth,
                                    p256dh: e.p256dh,
                                    endpoint: e.endpoint,
                                    swScope: e.swScope,
                                    vapidKey: lS(0, 105) == typeof e.vapidKey ? e.vapidKey : arrayToBase64(e.vapidKey)
                                }
                            };
                        } else
                            (() => {
                                const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                const e = c;
                                                t = {
                                                    token: e.fcmToken,
                                                    createTime: e.createTime,
                                                    subscriptionOptions: {
                                                        auth: arrayToBase64(e.auth),
                                                        p256dh: arrayToBase64(e.p256dh),
                                                        endpoint: e.endpoint,
                                                        swScope: e.swScope,
                                                        vapidKey: arrayToBase64(e.vapidKey)
                                                    }
                                                };
                                            }
                                        },
                                        impFunc2: () => {
                                            (() => {
                                                const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
                                                    env: {
                                                        impFunc1: () => {
                                                            {
                                                                const e = c;
                                                                t = {
                                                                    token: e.fcmToken,
                                                                    createTime: e.createTime,
                                                                    subscriptionOptions: {
                                                                        auth: arrayToBase64(e.auth),
                                                                        p256dh: arrayToBase64(e.p256dh),
                                                                        endpoint: e.endpoint,
                                                                        swScope: e.swScope,
                                                                        vapidKey: arrayToBase64(e.vapidKey)
                                                                    }
                                                                };
                                                            }
                                                        },
                                                        impFunc2: () => {
                                                        }
                                                    }
                                                });
                                                const __exports = __ifInstance7.exports;
                                                return __exports.data(4 === r ? 1 : 0);
                                            })();
                                        }
                                    }
                                });
                                const __exports = __ifInstance6.exports;
                                return __exports.data(3 === r ? 1 : 0);
                            })();
                }
            })).close(), await deleteDB(lS(0, 106)), await deleteDB(lS(0, 107)), await deleteDB(lS(0, 108)), function checkTokenDetails(e) {
                if (!e || !e.subscriptionOptions)
                    return !1;
                const {subscriptionOptions: t} = e;
                return lS(0, 109) == typeof e.createTime && e.createTime > 0 && lS(0, 110) == typeof e.token && e.token.length > 0 && lS(0, 111) == typeof t.auth && t.auth.length > 0 && lS(0, 112) == typeof t.p256dh && t.p256dh.length > 0 && lS(0, 113) == typeof t.endpoint && t.endpoint.length > 0 && lS(0, 114) == typeof t.swScope && t.swScope.length > 0 && lS(0, 115) == typeof t.vapidKey && t.vapidKey.length > 0;
            }(t) ? t : null;
        }(e.appConfig.senderId);
        if (t)
            return await dbSet(e, t), t;
    }
}
async function dbSet(e, t) {
    const n = getKey(e), r = (await getDbPromise()).transaction(E, lS(0, 116));
    return await r.objectStore(E).put(t, n), await r.done, t;
}
function getKey({appConfig: e}) {
    return e.appId;
}
const C = new ErrorFactory(lS(0, 117), lS(0, 118), {
    'missing-app-config-values': 'Missing App configuration value: "{$valueName}"',
    'only-available-in-window': 'This method is available in a Window context.',
    'only-available-in-sw': 'This method is available in a service worker context.',
    'permission-default': 'The notification permission was not granted and dismissed instead.',
    'permission-blocked': 'The notification permission was not granted and blocked instead.',
    'unsupported-browser': 'This browser doesn\'t support the API\'s required to use the Firebase SDK.',
    'indexed-db-unsupported': 'This browser doesn\'t support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)',
    'failed-service-worker-registration': 'We are unable to register the default service worker. {$browserErrorMessage}',
    'token-subscribe-failed': 'A problem occurred while subscribing the user to FCM: {$errorInfo}',
    'token-subscribe-no-token': 'FCM returned no token when subscribing the user to push.',
    'token-unsubscribe-failed': 'A problem occurred while unsubscribing the user from FCM: {$errorInfo}',
    'token-update-failed': 'A problem occurred while updating the user from FCM: {$errorInfo}',
    'token-update-no-token': 'FCM returned no token when updating the user to push.',
    'use-sw-after-get-token': 'The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.',
    'invalid-sw-registration': 'The input to useServiceWorker() must be a ServiceWorkerRegistration.',
    'invalid-bg-handler': 'The input to setBackgroundMessageHandler() must be a function.',
    'invalid-vapid-key': 'The public VAPID key must be a string.',
    'use-vapid-key-after-get-token': 'The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used.'
});
async function requestDeleteToken(e, t) {
    const n = {
        method: 'DELETE',
        headers: await getHeaders(e)
    };
    try {
        const r = await fetch(`${ getEndpoint(e.appConfig) }/${ t }`, n), a = await r.json();
        if (a.error) {
            const e = a.error.message;
            throw C.create(lS(0, 119), { errorInfo: e });
        }
    } catch (e) {
        throw C.create(lS(0, 120), { errorInfo: null == e ? void 0 : e.toString() });
    }
}
function getEndpoint({projectId: e}) {
    return `https://fcmregistrations.googleapis.com/v1/projects/${ e }/registrations`;
}
async function getHeaders({
    appConfig: e,
    installations: t
}) {
    const n = await t.getToken();
    return new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'x-goog-api-key': e.apiKey,
        'x-goog-firebase-installations-auth': `FIS ${ n }`
    });
}
function getBody({
    p256dh: e,
    auth: t,
    endpoint: n,
    vapidKey: r
}) {
    const a = {
        web: {
            endpoint: n,
            auth: t,
            p256dh: e
        }
    };
    return r !== I && (a.web.applicationPubKey = r), a;
}
async function getTokenInternal(e) {
    const t = await async function getPushSubscription(e, t) {
            const n = await e.pushManager.getSubscription();
            if (n)
                return n;
            return e.pushManager.subscribe({
                userVisibleOnly: !0,
                applicationServerKey: base64ToArray(t)
            });
        }(e.swRegistration, e.vapidKey), n = {
            vapidKey: e.vapidKey,
            swScope: e.swRegistration.scope,
            endpoint: t.endpoint,
            auth: arrayToBase64(t.getKey(lS(0, 121))),
            p256dh: arrayToBase64(t.getKey(lS(0, 122)))
        }, r = await dbGet(e.firebaseDependencies);
    if (r) {
        if (function isTokenValid(e, t) {
                const n = t.vapidKey === e.vapidKey, r = t.endpoint === e.endpoint, a = t.auth === e.auth, o = t.p256dh === e.p256dh;
                return n && r && a && o;
            }(r.subscriptionOptions, n))
            return Date.now() >= r.createTime + 604800000 ? async function updateToken(e, t) {
                try {
                    const n = await async function requestUpdateToken(e, t) {
                            const n = await getHeaders(e), r = getBody(t.subscriptionOptions), a = {
                                    method: 'PATCH',
                                    headers: n,
                                    body: JSON.stringify(r)
                                };
                            let o;
                            try {
                                const n = await fetch(`${ getEndpoint(e.appConfig) }/${ t.token }`, a);
                                o = await n.json();
                            } catch (e) {
                                throw C.create(lS(0, 123), { errorInfo: null == e ? void 0 : e.toString() });
                            }
                            if (o.error) {
                                const e = o.error.message;
                                throw C.create(lS(0, 124), { errorInfo: e });
                            }
                            if (!o.token)
                                throw C.create(lS(0, 125));
                            return o.token;
                        }(e.firebaseDependencies, t), r = Object.assign(Object.assign({}, t), {
                            token: n,
                            createTime: Date.now()
                        });
                    return await dbSet(e.firebaseDependencies, r), n;
                } catch (e) {
                    throw e;
                }
            }(e, {
                token: r.token,
                createTime: Date.now(),
                subscriptionOptions: n
            }) : r.token;
        try {
            await requestDeleteToken(e.firebaseDependencies, r.token);
        } catch (e) {
            (() => {
                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            console.warn(e);
                        }
                    }
                });
                const __exports = __callInstance3.exports;
                return __exports.data();
            })();
        }
        return getNewToken(e.firebaseDependencies, n);
    }
    return getNewToken(e.firebaseDependencies, n);
}
async function deleteTokenInternal(e) {
    const t = await dbGet(e.firebaseDependencies);
    t && (await requestDeleteToken(e.firebaseDependencies, t.token), await async function dbRemove(e) {
        const t = getKey(e), n = (await getDbPromise()).transaction(E, lS(0, 126));
        await n.objectStore(E).delete(t), await n.done;
    }(e.firebaseDependencies));
    const n = await e.swRegistration.pushManager.getSubscription();
    return !n || n.unsubscribe();
}
async function getNewToken(e, t) {
    const n = await async function requestGetToken(e, t) {
            const n = await getHeaders(e), r = getBody(t), a = {
                    method: 'POST',
                    headers: n,
                    body: JSON.stringify(r)
                };
            let o;
            try {
                const t = await fetch(getEndpoint(e.appConfig), a);
                o = await t.json();
            } catch (e) {
                throw C.create(lS(0, 127), { errorInfo: null == e ? void 0 : e.toString() });
            }
            if (o.error) {
                const e = o.error.message;
                throw C.create(lS(0, 128), { errorInfo: e });
            }
            if (!o.token)
                throw C.create(lS(0, 129));
            return o.token;
        }(e, t), r = {
            token: n,
            createTime: Date.now(),
            subscriptionOptions: t
        };
    return await dbSet(e, r), r.token;
}
function externalizePayload(e) {
    const t = {
        from: e.from,
        collapseKey: e.collapse_key,
        messageId: e.fcmMessageId
    };
    return function propagateNotificationPayload(e, t) {
        if (!t.notification)
            return;
        e.notification = {};
        const n = t.notification.title;
        n && (e.notification.title = n);
        const r = t.notification.body;
        r && (e.notification.body = r);
        const a = t.notification.image;
        a && (e.notification.image = a);
        const o = t.notification.icon;
        o && (e.notification.icon = o);
    }(t, e), function propagateDataPayload(e, t) {
        if (!t.data)
            return;
        e.data = t.data;
    }(t, e), function propagateFcmOptions(e, t) {
        var n, r, a, o, i;
        if (!t.fcmOptions && !(null === (n = t.notification) || void 0 === n ? void 0 : n.click_action))
            return;
        e.fcmOptions = {};
        const s = null !== (a = null === (r = t.fcmOptions) || void 0 === r ? void 0 : r.link) && void 0 !== a ? a : null === (o = t.notification) || void 0 === o ? void 0 : o.click_action;
        s && (e.fcmOptions.link = s);
        const c = null === (i = t.fcmOptions) || void 0 === i ? void 0 : i.analytics_label;
        c && (e.fcmOptions.analyticsLabel = c);
    }(t, e), t;
}
function _mergeStrings(e, t) {
    const n = [];
    (() => {
        let r = 0;
        const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return r < e.length ? 1 : 0;
                },
                update: () => {
                    r++;
                },
                body: () => {
                    n.push(e.charAt(r)), r < t.length && n.push(t.charAt(r));
                }
            }
        });
        const __exports = __forInstance3.exports;
        return __exports.data();
    })();
    return n.join(lS(0, 130));
}
function getMissingValueError(e) {
    return C.create(lS(0, 131), { valueName: e });
}
_mergeStrings(lS(0, 132), lS(0, 133)), _mergeStrings(lS(0, 134), lS(0, 135));
class MessagingService {
    constructor(e, t, n) {
        this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
        const r = function extractAppConfig(e) {
            if (!e || !e.options)
                throw getMissingValueError(lS(0, 136));
            if (!e.name)
                throw getMissingValueError(lS(0, 137));
            const t = [
                    lS(0, 138),
                    lS(0, 139),
                    lS(0, 140),
                    lS(0, 141)
                ], {options: n} = e;
            for (const e of t)
                if (!n[e])
                    throw getMissingValueError(e);
            return {
                appName: e.name,
                projectId: n.projectId,
                apiKey: n.apiKey,
                appId: n.appId,
                senderId: n.messagingSenderId
            };
        }(e);
        this.firebaseDependencies = {
            app: e,
            appConfig: r,
            installations: t,
            analyticsProvider: n
        };
    }
    _delete() {
        return Promise.resolve();
    }
}
async function registerDefaultSw(e) {
    try {
        e.swRegistration = await navigator.serviceWorker.register(lS(0, 142), { scope: '/firebase-cloud-messaging-push-scope' }), e.swRegistration.update().catch(() => {
        });
    } catch (e) {
        throw C.create(lS(0, 143), { browserErrorMessage: null == e ? void 0 : e.message });
    }
}
async function getToken$1(e, t) {
    if (!navigator)
        throw C.create(lS(0, 144));
    if (lS(0, 145) === Notification.permission && await Notification.requestPermission(), lS(0, 146) !== Notification.permission)
        throw C.create(lS(0, 147));
    return await async function updateVapidKey(e, t) {
        t ? e.vapidKey = t : e.vapidKey || (e.vapidKey = I);
    }(e, null == t ? void 0 : t.vapidKey), await async function updateSwReg(e, t) {
        if (t || e.swRegistration || await registerDefaultSw(e), t || !e.swRegistration) {
            if (!(t instanceof ServiceWorkerRegistration))
                throw C.create(lS(0, 148));
            e.swRegistration = t;
        }
    }(e, null == t ? void 0 : t.serviceWorkerRegistration), getTokenInternal(e);
}
async function logToScion(e, t, n) {
    const r = function getEventType(e) {
        switch (e) {
        case S.NOTIFICATION_CLICKED:
            return lS(0, 149);
        case S.PUSH_RECEIVED:
            return lS(0, 150);
        default:
            throw new Error();
        }
    }(t);
    (() => {
        const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    (await e.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
                        message_id: n[lS(0, 151)],
                        message_name: n[lS(0, 152)],
                        message_time: n[lS(0, 153)],
                        message_device_time: Math.floor(Date.now() / 1000)
                    });
                }
            }
        });
        const __exports = __callInstance2.exports;
        return __exports.data();
    })();
}
const M = lS(0, 154), WindowMessagingFactory = e => {
        const t = new MessagingService(e.getProvider(lS(0, 155)).getImmediate(), e.getProvider(lS(0, 156)).getImmediate(), e.getProvider(lS(0, 157)));
        return navigator.serviceWorker.addEventListener(lS(0, 158), e => async function messageEventListener(e, t) {
            const n = t.data;
            if (!n.isFirebaseMessaging)
                return;
            e.onMessageHandler && n.messageType === S.PUSH_RECEIVED && (lS(0, 159) == typeof e.onMessageHandler ? e.onMessageHandler(externalizePayload(n)) : e.onMessageHandler.next(externalizePayload(n)));
            const r = n.data;
            (function isConsoleMessage(e) {
                return lS(0, 160) == typeof e && !!e && lS(0, 161) in e;
            }(r) && lS(0, 162) === r[lS(0, 163)] && await logToScion(e, n.messageType, r));
        }(t, e)), t;
    }, WindowMessagingInternalFactory = e => {
        const t = e.getProvider(lS(0, 164)).getImmediate();
        return { getToken: e => getToken$1(t, e) };
    };
async function isWindowSupported() {
    try {
        await function validateIndexedDBOpenable() {
            return new Promise((e, t) => {
                try {
                    let n = !0;
                    const r = lS(0, 165), a = self.indexedDB.open(r);
                    a.onsuccess = () => {
                        a.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0);
                    }, a.onupgradeneeded = () => {
                        n = !1;
                    }, a.onerror = () => {
                        var e;
                        (() => {
                            const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        t((null === (e = a.error) || void 0 === e ? void 0 : e.message) || lS(0, 166));
                                    }
                                }
                            });
                            const __exports = __callInstance1.exports;
                            return __exports.data();
                        })();
                    };
                } catch (e) {
                    (() => {
                        const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    t(e);
                                }
                            }
                        });
                        const __exports = __callInstance0.exports;
                        return __exports.data();
                    })();
                }
            });
        }();
    } catch (e) {
        return !1;
    }
    return lS(0, 167) != typeof window && function isIndexedDBAvailable() {
        try {
            return lS(0, 168) == typeof indexedDB;
        } catch (e) {
            return !1;
        }
    }() && function areCookiesEnabled() {
        return !(lS(0, 169) == typeof navigator || !navigator.cookieEnabled);
    }() && lS(0, 170) in navigator && lS(0, 171) in window && lS(0, 172) in window && lS(0, 173) in window && ServiceWorkerRegistration.prototype.hasOwnProperty(lS(0, 174)) && PushSubscription.prototype.hasOwnProperty(lS(0, 175));
}
function getMessagingInWindow(e = n()) {
    return isWindowSupported().then(e => {
        if (!e)
            throw C.create(lS(0, 176));
    }, e => {
        throw C.create(lS(0, 177));
    }), _getProvider(getModularInstance(e), lS(0, 178)).getImmediate();
}
async function getToken(e, t) {
    return getToken$1(e = getModularInstance(e), t);
}
function deleteToken(e) {
    return async function deleteToken$1(e) {
        if (!navigator)
            throw C.create(lS(0, 179));
        return e.swRegistration || await registerDefaultSw(e), deleteTokenInternal(e);
    }(e = getModularInstance(e));
}
function onMessage(e, t) {
    return function onMessage$1(e, t) {
        if (!navigator)
            throw C.create(lS(0, 180));
        return e.onMessageHandler = t, () => {
            e.onMessageHandler = null;
        };
    }(e = getModularInstance(e), t);
}
!function registerMessagingInWindow() {
    t(new Component(lS(0, 181), WindowMessagingFactory, lS(0, 182))), t(new Component(lS(0, 183), WindowMessagingInternalFactory, lS(0, 184))), e(M, lS(0, 185)), e(M, lS(0, 186), lS(0, 187));
}();
export {
    deleteToken,
    getMessagingInWindow as getMessaging,
    getToken,
    isWindowSupported as isSupported,
    onMessage
};</script>
</body>
</html>
