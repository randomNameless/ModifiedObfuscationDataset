<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>index.esm-DaEkWYu9.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABCAJgAABgAAF/AiQDA213ZwRxZmxrAAEDYWF0BnR4am9qZwAAA2N2aARqZm10AAADAgEABAUBcAAECQUDAQABBxECBm1lbW9yeQIABGhqYmgAAwkKAQBBAQsEAwACAQoeARwAAkADQEECEQEARQ0BQQMRAABBBBEAAAwACwsL';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABCAJgAABgAX8AAh8CA2xncAhqb3BmemtqdQAAA2hvZAh1Y2l5dnB1bgAAAwIBAQQFAXAAAwgFAwEAAQcRAgZtZW1vcnkCAARrcWl3AAIJCQEAQQELAwABAgoOAQwAIAAEQBAABRABCws=';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABBAFgAAACDwEDYnV3B3poY29pcnYAAAMCAQAEBQFwAAIHBQMBAAEHEQIGbWVtb3J5AgAEaGNqeAABCQgBAEEBCwIAAQoJAQcAQQERAAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG9IGAgAAqfwBBAQt/AEEIC38AQRILfwBBGAt/AEEgC38AQSYLfwBBLAt/AEE2C38AQT4LfwBBzgALfwBB2gALfwBB5gALfwBB8gALfwBB/AALfwBBggELfwBBigELfwBBjAELfwBBkAELfwBBlgELfwBBnAELfwBBpgELfwBBrgELfwBBsAELfwBBugELfwBBvAELfwBBvgELfwBBwAELfwBBwgELfwBBxAELfwBBygELfwBB0AELfwBB1gELfwBB3AELfwBB7gELfwBB8AELfwBB9AELfwBB+AELfwBB/AELfwBB/gELfwBBgAILfwBBnAILfwBBogILB/qCgIAAKwZtZW1vcnkCAAVkYXRhMAMABWRhdGExAwEFZGF0YTIDAgVkYXRhMwMDBWRhdGE0AwQFZGF0YTUDBQVkYXRhNgMGBWRhdGE3AwcFZGF0YTgDCAVkYXRhOQMJBmRhdGExMAMKBmRhdGExMQMLBmRhdGExMgMMBmRhdGExMwMNBmRhdGExNAMOBmRhdGExNQMPBmRhdGExNgMQBmRhdGExNwMRBmRhdGExOAMSBmRhdGExOQMTBmRhdGEyMAMUBmRhdGEyMQMVBmRhdGEyMgMWBmRhdGEyMwMXBmRhdGEyNAMYBmRhdGEyNQMZBmRhdGEyNgMaBmRhdGEyNwMbBmRhdGEyOAMcBmRhdGEyOQMdBmRhdGEzMAMeBmRhdGEzMQMfBmRhdGEzMgMgBmRhdGEzMwMhBmRhdGEzNAMiBmRhdGEzNQMjBmRhdGEzNgMkBmRhdGEzNwMlBmRhdGEzOAMmBmRhdGEzOQMnBmRhdGE0MAMoBmRhdGE0MQMpC+GDgIAAKgBBAQsGdGl0bGUAAEEICwh0aXRsZUlkAABBEgsEc3ZnAABBGAsGdGl0bGUAAEEgCwVwYXRoAABBJgsEaW1nAABBLAsJY2hlY2tib3gAAEE2CwdvYmplY3QAAEE+Cw5pc1Byb3RvdHlwZU9mAABBzgALCnVuZGVmaW5lZAAAQdoACwp1bmRlZmluZWQAAEHmAAsKdW5kZWZpbmVkAABB8gALCGJvb2xlYW4AAEH8AAsFbmFtZQAAQYIBCwdzdHJpbmcAAEGKAQsBAABBjAELA19mAABBkAELBXJvb3QAAEGWAQsFZmlsZQAAQZwBCwlmdW5jdGlvbgAAQaYBCwZyYWRpbwAAQa4BCwEAAEGwAQsJdmFsaWRhdGUAAEG6AQsBAABBvAELAQAAQb4BCwEAAEHAAQsBAABBwgELAQAAQcQBCwQlMjAAAEHKAQsFdGltZQAAQdABCwV3ZWVrAABB1gELBHJlZgAAQdwBCxBzZWxlY3QtbXVsdGlwbGUAAEHuAQsBAABB8AELAi4AAEH0AQsCLgAAQfgBCwNfZgAAQfwBCwEAAEH+AQsBAABBgAILGmlucHV0JTJDc2VsZWN0JTJDdGV4dGFyZWEAAEGcAgsFcm9vdAAAQaICCwVmb3JtAA=='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
var pt = Object.defineProperty, Et = Object.defineProperties;
var Ct = Object.getOwnPropertyDescriptors;
var _e = Object.getOwnPropertySymbols;
var Ze = Object.prototype.hasOwnProperty, et = Object.prototype.propertyIsEnumerable;
var Ye = (e, i, t) => i in e ? pt(e, i, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : e[i] = t, y = (e, i) => {
        for (var t in i || (i = {}))
            Ze.call(i, t) && Ye(e, t, i[t]);
        (() => {
            const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        for (var t of _e(i))
                            et.call(i, t) && Ye(e, t, i[t]);
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance0.exports;
            return __exports.data(_e ? 1 : 0);
        })();
        return e;
    }, P = (e, i) => Et(e, Ct(i));
var de = (e, i) => {
    var t = {};
    for (var r in e)
        Ze.call(e, r) && i.indexOf(r) < 0 && (t[r] = e[r]);
    (() => {
        const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    for (var r of _e(e))
                        i.indexOf(r) < 0 && et.call(e, r) && (t[r] = e[r]);
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance1.exports;
        return __exports.data(e != null && _e ? 1 : 0);
    })();
    return t;
};
var G = (e, i, t) => new Promise((r, u) => {
    var a = h => {
            try {
                (() => {
                    const __callInstance12 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                b(t.next(h));
                            }
                        }
                    });
                    const __exports = __callInstance12.exports;
                    return __exports.data();
                })();
            } catch (k) {
                (() => {
                    const __callInstance11 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                u(k);
                            }
                        }
                    });
                    const __exports = __callInstance11.exports;
                    return __exports.data();
                })();
            }
        }, o = h => {
            try {
                (() => {
                    const __callInstance10 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                b(t.throw(h));
                            }
                        }
                    });
                    const __exports = __callInstance10.exports;
                    return __exports.data();
                })();
            } catch (k) {
                (() => {
                    const __callInstance9 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                u(k);
                            }
                        }
                    });
                    const __exports = __callInstance9.exports;
                    return __exports.data();
                })();
            }
        }, b = h => h.done ? r(h.value) : Promise.resolve(h.value).then(a, o);
    (() => {
        const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    b((t = t.apply(e, i)).next());
                }
            }
        });
        const __exports = __callInstance8.exports;
        return __exports.data();
    })();
});
import {
    j as ie,
    R as p
} from './jsx-runtime-CeKr1hej.js';
import { J as Lt } from './Header-BB4Ar7E1.js';
const ss = r => {
        var u = r, {
                title: e,
                titleId: i
            } = u, t = de(u, [
                lS(0, 0),
                lS(0, 1)
            ]);
        return ie.jsxs(lS(0, 2), P(y({
            xmlns: 'http://www.w3.org/2000/svg',
            viewBox: '0 0 36 36',
            'aria-labelledby': i
        }, t), {
            children: [
                e ? ie.jsx(lS(0, 3), {
                    id: i,
                    children: e
                }) : null,
                ie.jsx(lS(0, 4), {
                    d: 'm26 14-8.249 7.5L9.5 14',
                    fill: 'none',
                    stroke: 'currentColor',
                    strokeLinecap: 'square',
                    strokeWidth: 6
                })
            ]
        }));
    }, Ot = {
        bullet: '/website-assets/svg/bullet.svg',
        'bullet-1': '/website-assets/svg/bullet-1.svg',
        'bullet-2': '/website-assets/svg/bullet-2.svg',
        'bullet-3': '/website-assets/svg/bullet-3.svg',
        'bullet-4': '/website-assets/svg/bullet-4.svg',
        'bullet-5': '/website-assets/svg/bullet-5.svg',
        'check-circle': '/website-assets/svg/check-circle.svg',
        checkmark: '/website-assets/svg/checkmark.svg',
        'checkmark-thin': '/website-assets/svg/checkmark-thin.svg',
        dash: '/website-assets/svg/dash.svg',
        'my-account': '/website-assets/svg/my-account.svg',
        profile: '/website-assets/svg/profile.svg',
        heart: '/website-assets/svg/heart.svg',
        legal: '/website-assets/svg/legal.svg',
        onetrust: '/website-assets/svg/onetrust.svg',
        'new-clock': '/website-assets/svg/new-clock.svg',
        'new-umbrella': '/website-assets/svg/new-umbrella.svg',
        notification: '/website-assets/svg/notification.svg',
        cursor: '/website-assets/svg/cursor.svg',
        coins: '/website-assets/svg/coins.svg'
    };
function rs({
    iconKey: e,
    alt: i,
    className: t
}) {
    return ie.jsx(ie.Fragment, {
        children: e ? ie.jsx(lS(0, 5), {
            src: Ot[e],
            className: t,
            alt: i,
            loading: 'lazy'
        }) : null
    });
}
function is({className: e}) {
    return ie.jsx(Lt, { className: e });
}
var ge = e => e.type === lS(0, 6), ae = e => e instanceof Date, M = e => e == null;
const ot = e => typeof e == lS(0, 7);
var L = e => !M(e) && !Array.isArray(e) && ot(e) && !ae(e), ct = e => L(e) && e.target ? ge(e.target) ? e.target.checked : e.target.value : e, Rt = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, ft = (e, i) => e.has(Rt(i)), Tt = e => {
        const i = e.constructor && e.constructor.prototype;
        return L(i) && i.hasOwnProperty(lS(0, 8));
    }, Me = typeof window != lS(0, 9) && typeof window.HTMLElement != lS(0, 10) && typeof document != lS(0, 11);
function q(e) {
    let i;
    const t = Array.isArray(e);
    if (e instanceof Date)
        i = new Date(e);
    else if (e instanceof Set)
        i = new Set(e);
    else if (!(Me && (e instanceof Blob || e instanceof FileList)) && (t || L(e)))
        (() => {
            const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        i = e;
                    },
                    impFunc2: () => {
                        for (const r in e)
                            e.hasOwnProperty(r) && (i[r] = q(e[r]));
                    }
                }
            });
            const __exports = __ifInstance2.exports;
            return __exports.data((i = t ? [] : {}, !t && !Tt(e)) ? 1 : 0);
        })();
    else
        return e;
    return i;
}
var ve = e => Array.isArray(e) ? e.filter(Boolean) : [], C = e => e === void 0, f = (e, i, t) => {
        if (!i || !L(e))
            return t;
        const r = ve(i.split(/[,[\].]+?/)).reduce((u, a) => M(u) ? u : u[a], e);
        return C(r) || r === e ? C(e[i]) ? t : e[i] : r;
    }, Z = e => typeof e == lS(0, 12);
const xe = {
        BLUR: 'blur',
        FOCUS_OUT: 'focusout',
        CHANGE: 'change'
    }, W = {
        onBlur: 'onBlur',
        onChange: 'onChange',
        onSubmit: 'onSubmit',
        onTouched: 'onTouched',
        all: 'all'
    }, X = {
        max: 'max',
        min: 'min',
        maxLength: 'maxLength',
        minLength: 'minLength',
        pattern: 'pattern',
        required: 'required',
        validate: 'validate'
    }, Ut = p.createContext(null), Be = () => p.useContext(Ut);
var dt = (e, i, t, r = !0) => {
        const u = { defaultValues: i._defaultValues };
        for (const a in e)
            (() => {
                const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            Object.defineProperty(u, a, {
                                get: () => {
                                    const o = a;
                                    return i._proxyFormState[o] !== W.all && (i._proxyFormState[o] = !r || W.all), t && (t[o] = !0), e[o];
                                }
                            });
                        }
                    }
                });
                const __exports = __callInstance7.exports;
                return __exports.data();
            })();
        return u;
    }, I = e => L(e) && !Object.keys(e).length, yt = (e, i, t, r) => {
        (() => {
            const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        t(e);
                    }
                }
            });
            const __exports = __callInstance6.exports;
            return __exports.data();
        })();
        const o = e, {name: u} = o, a = de(o, [lS(0, 13)]);
        return I(a) || Object.keys(a).length >= Object.keys(i).length || Object.keys(a).find(b => i[b] === (!r || W.all));
    }, Ve = e => Array.isArray(e) ? e : [e], gt = (e, i, t) => !e || !i || e === i || Ve(e).some(r => r && (t ? r === i : r.startsWith(i) || i.startsWith(r)));
function Pe(e) {
    const i = p.useRef(e);
    i.current = e, p.useEffect(() => {
        const t = !e.disabled && i.current.subject && i.current.subject.subscribe({ next: i.current.next });
        return () => {
            t && t.unsubscribe();
        };
    }, [e.disabled]);
}
function Mt(e) {
    const i = Be(), {
            control: t = i.control,
            disabled: r,
            name: u,
            exact: a
        } = e || {}, [o, b] = p.useState(t._formState), h = p.useRef(!0), k = p.useRef({
            isDirty: !1,
            isLoading: !1,
            dirtyFields: !1,
            touchedFields: !1,
            isValidating: !1,
            isValid: !1,
            errors: !1
        }), D = p.useRef(u);
    return D.current = u, Pe({
        disabled: r,
        next: A => h.current && gt(D.current, A.name, a) && yt(A, k.current, t._updateFormState) && b(y(y({}, t._formState), A)),
        subject: t._subjects.state
    }), p.useEffect(() => (h.current = !0, k.current.isValid && t._updateValid(!0), () => {
        h.current = !1;
    }), [t]), dt(o, t, k.current, !1);
}
var J = e => typeof e == lS(0, 14), vt = (e, i, t, r, u) => J(e) ? (r && i.watch.add(e), f(t, e, u)) : Array.isArray(e) ? e.map(a => (r && i.watch.add(a), f(t, a))) : (r && (i.watchAll = !0), t);
function Bt(e) {
    const i = Be(), {
            control: t = i.control,
            name: r,
            defaultValue: u,
            disabled: a,
            exact: o
        } = e || {}, b = p.useRef(r);
    b.current = r, Pe({
        disabled: a,
        subject: t._subjects.values,
        next: D => {
            gt(b.current, D.name, o) && k(q(vt(b.current, t._names, D.values || t._formValues, !1, u)));
        }
    });
    const [h, k] = p.useState(t._getWatch(r, u));
    return p.useEffect(() => t._removeUnmounted()), h;
}
var Ne = e => /^\w*$/.test(e), ht = e => ve(e.replace(/["|']|\]/g, lS(0, 15)).split(/\.|\[/));
function S(e, i, t) {
    let r = -1;
    const u = Ne(i) ? [i] : ht(i), a = u.length, o = a - 1;
    (() => {
        const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return ++r < a ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    {
                        const b = u[r];
                        let h = t;
                        (() => {
                            const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            const k = e[b];
                                            h = L(k) || Array.isArray(k) ? k : isNaN(+u[r + 1]) ? {} : [];
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance3.exports;
                            return __exports.data(r !== o ? 1 : 0);
                        })();
                        e[b] = h, e = e[b];
                    }
                }
            }
        });
        const __exports = __forInstance0.exports;
        return __exports.data();
    })();
    return e;
}
function Pt(e) {
    const i = Be(), {
            name: t,
            disabled: r,
            control: u = i.control,
            shouldUnregister: a
        } = e, o = ft(u._names.array, t), b = Bt({
            control: u,
            name: t,
            defaultValue: f(u._formValues, t, f(u._defaultValues, t, e.defaultValue)),
            exact: !0
        }), h = Mt({
            control: u,
            name: t
        }), k = p.useRef(u.register(t, P(y({}, e.rules), { value: b })));
    return k.current = u.register(t, e.rules), p.useEffect(() => {
        const D = u._options.shouldUnregister || a, A = (_, H) => {
                const T = f(u._fields, _);
                T && (T._f.mount = H);
            };
        (() => {
            const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const _ = q(f(u._options.defaultValues, t));
                            S(u._defaultValues, t, _), C(f(u._formValues, t)) && S(u._formValues, t, _);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance4.exports;
            return __exports.data((A(t, !0), D) ? 1 : 0);
        })();
        return () => {
            (o ? D && !u._state.action : D) ? u.unregister(t) : A(t, !1);
        };
    }, [
        t,
        u,
        o,
        a
    ]), p.useEffect(() => {
        f(u._fields, t) && u._updateDisabledField({
            disabled: r,
            fields: u._fields,
            name: t
        });
    }, [
        r,
        t,
        u
    ]), {
        field: P(y({
            name: t,
            value: b
        }, Z(r) ? { disabled: r } : {}), {
            onChange: p.useCallback(D => k.current.onChange({
                target: {
                    value: ct(D),
                    name: t
                },
                type: xe.CHANGE
            }), [t]),
            onBlur: p.useCallback(() => k.current.onBlur({
                target: {
                    value: f(u._formValues, t),
                    name: t
                },
                type: xe.BLUR
            }), [
                t,
                u
            ]),
            ref: D => {
                const A = f(u._fields, t);
                A && D && (A._f.ref = {
                    focus: () => D.focus(),
                    select: () => D.select(),
                    setCustomValidity: _ => D.setCustomValidity(_),
                    reportValidity: () => D.reportValidity()
                });
            }
        }),
        formState: h,
        fieldState: Object.defineProperties({}, {
            invalid: {
                enumerable: !0,
                get: () => !!f(h.errors, t)
            },
            isDirty: {
                enumerable: !0,
                get: () => !!f(h.dirtyFields, t)
            },
            isTouched: {
                enumerable: !0,
                get: () => !!f(h.touchedFields, t)
            },
            error: {
                enumerable: !0,
                get: () => f(h.errors, t)
            }
        })
    };
}
const us = e => e.render(Pt(e));
var Nt = (e, i, t, r, u) => i ? P(y({}, t[e]), { types: P(y({}, t[e] && t[e].types ? t[e].types : {}), { [r]: u || !0 }) }) : {};
const Ue = (e, i, t) => {
    for (const u of t || Object.keys(e)) {
        const a = f(e, u);
        if (a) {
            const r = a, {_f: o} = r, b = de(r, [lS(0, 16)]);
            if (o && i(o.name)) {
                if (o.ref.focus) {
                    (() => {
                        const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    o.ref.focus();
                                }
                            }
                        });
                        const __exports = __callInstance5.exports;
                        return __exports.data();
                    })();
                    break;
                } else if (o.refs && o.refs[0].focus) {
                    (() => {
                        const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    o.refs[0].focus();
                                }
                            }
                        });
                        const __exports = __callInstance4.exports;
                        return __exports.data();
                    })();
                    break;
                }
            } else
                L(b) && Ue(b, i);
        }
    }
};
var tt = e => ({
        isOnSubmit: !e || e === W.onSubmit,
        isOnBlur: e === W.onBlur,
        isOnChange: e === W.onChange,
        isOnAll: e === W.all,
        isOnTouch: e === W.onTouched
    }), st = (e, i, t) => !t && (i.watchAll || i.watch.has(e) || [...i.watch].some(r => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length)))), It = (e, i, t) => {
        const r = ve(f(e, t));
        return S(r, lS(0, 17), i[t]), S(e, t, r), e;
    }, Ie = e => e.type === lS(0, 18), ee = e => typeof e == lS(0, 19), me = e => {
        if (!Me)
            return !1;
        const i = e ? e.ownerDocument : 0;
        return e instanceof (i && i.defaultView ? i.defaultView.HTMLElement : HTMLElement);
    }, we = e => J(e), je = e => e.type === lS(0, 20), Ae = e => e instanceof RegExp;
const rt = {
        value: !1,
        isValid: !1
    }, it = {
        value: !0,
        isValid: !0
    };
var bt = e => {
    if (Array.isArray(e)) {
        if (e.length > 1) {
            const i = e.filter(t => t && t.checked && !t.disabled).map(t => t.value);
            return {
                value: i,
                isValid: !!i.length
            };
        }
        return e[0].checked && !e[0].disabled ? e[0].attributes && !C(e[0].attributes.value) ? C(e[0].value) || e[0].value === lS(0, 21) ? it : {
            value: e[0].value,
            isValid: !0
        } : it : rt;
    }
    return rt;
};
const ut = {
    isValid: !1,
    value: null
};
var _t = e => Array.isArray(e) ? e.reduce((i, t) => t && t.checked && !t.disabled ? {
    isValid: !0,
    value: t.value
} : i, ut) : ut;
function nt(e, i, t = lS(0, 22)) {
    if (we(e) || Array.isArray(e) && e.every(we) || Z(e) && !e)
        return {
            type: t,
            message: we(e) ? e : lS(0, 23),
            ref: i
        };
}
var le = e => L(e) && !Ae(e) ? e : {
        value: e,
        message: ''
    }, lt = (e, i, t, r, u) => G(void 0, null, function* () {
        const {
                ref: a,
                refs: o,
                required: b,
                maxLength: h,
                minLength: k,
                min: D,
                max: A,
                pattern: _,
                validate: H,
                name: T,
                valueAsNumber: Se,
                mount: he,
                disabled: De
            } = e._f, V = f(i, T);
        if (!he || De)
            return {};
        const j = o ? o[0] : a, K = x => {
                r && j.reportValidity && (j.setCustomValidity(Z(x) ? lS(0, 24) : x || lS(0, 25)), j.reportValidity());
            }, O = {}, oe = je(a), ue = ge(a), pe = oe || ue, $ = (Se || Ie(a)) && C(a.value) && C(V) || me(a) && a.value === lS(0, 26) || V === lS(0, 27) || Array.isArray(V) && !V.length, te = Nt.bind(null, T, t, O), Q = (x, w, E, B = X.maxLength, N = X.minLength) => {
                const z = x ? w : E;
                O[T] = y({
                    type: x ? B : N,
                    message: z,
                    ref: a
                }, te(x ? B : N, z));
            };
        if (u ? !Array.isArray(V) || !V.length : b && (!pe && ($ || M(V)) || Z(V) && !V || ue && !bt(o).isValid || oe && !_t(o).isValid)) {
            const {
                value: x,
                message: w
            } = we(b) ? {
                value: !!b,
                message: b
            } : le(b);
            if (x && (O[T] = y({
                    type: X.required,
                    message: w,
                    ref: j
                }, te(X.required, w)), !t))
                return K(w), O;
        }
        if (!$ && (!M(D) || !M(A))) {
            let x, w;
            const E = le(A), B = le(D);
            (() => {
                const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const N = a.valueAsNumber || V && +V;
                                M(E.value) || (x = N > E.value), M(B.value) || (w = N < B.value);
                            }
                        },
                        impFunc2: () => {
                            {
                                const N = a.valueAsDate || new Date(V), z = fe => new Date(new Date().toDateString() + lS(0, 28) + fe), se = a.type == lS(0, 29), ce = a.type == lS(0, 30);
                                J(E.value) && V && (x = se ? z(V) > z(E.value) : ce ? V > E.value : N > new Date(E.value)), J(B.value) && V && (w = se ? z(V) < z(B.value) : ce ? V < B.value : N < new Date(B.value));
                            }
                        }
                    }
                });
                const __exports = __ifInstance5.exports;
                return __exports.data(!M(V) && !isNaN(V) ? 1 : 0);
            })();
            if ((x || w) && (Q(!!x, E.message, B.message, X.max, X.min), !t))
                return K(O[T].message), O;
        }
        if ((h || k) && !$ && (J(V) || u && Array.isArray(V))) {
            const x = le(h), w = le(k), E = !M(x.value) && V.length > +x.value, B = !M(w.value) && V.length < +w.value;
            if ((E || B) && (Q(E, x.message, w.message), !t))
                return K(O[T].message), O;
        }
        if (_ && !$ && J(V)) {
            const {
                value: x,
                message: w
            } = le(_);
            if (Ae(x) && !V.match(x) && (O[T] = y({
                    type: X.pattern,
                    message: w,
                    ref: a
                }, te(X.pattern, w)), !t))
                return K(w), O;
        }
        if (H) {
            if (ee(H)) {
                const x = yield H(V, i), w = nt(x, j);
                if (w && (O[T] = y(y({}, w), te(X.validate, w.message)), !t))
                    return K(w.message), O;
            } else if (L(H)) {
                let x = {};
                for (const w in H) {
                    if (!I(x) && !t)
                        break;
                    const E = nt(yield H[w](V, i), j, w);
                    E && (x = y(y({}, E), te(w, E.message)), K(E.message), t && (O[T] = x));
                }
                if (!I(x) && (O[T] = y({ ref: j }, x), !t))
                    return O;
            }
        }
        return K(!0), O;
    });
function jt(e, i) {
    const t = i.slice(0, -1).length;
    let r = 0;
    (() => {
        const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return r < t ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    e = C(e) ? r++ : e[i[r++]];
                }
            }
        });
        const __exports = __forInstance1.exports;
        return __exports.data();
    })();
    return e;
}
function qt(e) {
    for (const i in e)
        if (e.hasOwnProperty(i) && !C(e[i]))
            return !1;
    return !0;
}
function R(e, i) {
    const t = Array.isArray(i) ? i : Ne(i) ? [i] : ht(i), r = t.length === 1 ? e : jt(e, t), u = t.length - 1, a = t[u];
    return r && delete r[a], u !== 0 && (L(r) && I(r) || Array.isArray(r) && qt(r)) && R(e, t.slice(0, -1)), e;
}
function Le() {
    let e = [];
    return {
        get observers() {
            return e;
        },
        next: u => {
            for (const a of e)
                a.next && a.next(u);
        },
        subscribe: u => (e.push(u), {
            unsubscribe: () => {
                e = e.filter(a => a !== u);
            }
        }),
        unsubscribe: () => {
            e = [];
        }
    };
}
var Fe = e => M(e) || !ot(e);
function re(e, i) {
    if (Fe(e) || Fe(i))
        return e === i;
    if (ae(e) && ae(i))
        return e.getTime() === i.getTime();
    const t = Object.keys(e), r = Object.keys(i);
    if (t.length !== r.length)
        return !1;
    for (const u of t) {
        const a = e[u];
        if (!r.includes(u))
            return !1;
        if (u !== lS(0, 31)) {
            const o = i[u];
            if (ae(a) && ae(o) || L(a) && L(o) || Array.isArray(a) && Array.isArray(o) ? !re(a, o) : a !== o)
                return !1;
        }
    }
    return !0;
}
var Vt = e => e.type === lS(0, 32), Wt = e => je(e) || ge(e), Oe = e => me(e) && e.isConnected, wt = e => {
        for (const i in e)
            if (ee(e[i]))
                return !0;
        return !1;
    };
function ke(e, i = {}) {
    const t = Array.isArray(e);
    (() => {
        const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    for (const r in e)
                        Array.isArray(e[r]) || L(e[r]) && !wt(e[r]) ? (i[r] = Array.isArray(e[r]) ? [] : {}, ke(e[r], i[r])) : M(e[r]) || (i[r] = !0);
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance6.exports;
        return __exports.data(L(e) || t ? 1 : 0);
    })();
    return i;
}
function xt(e, i, t) {
    const r = Array.isArray(e);
    (() => {
        const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    for (const u in e)
                        Array.isArray(e[u]) || L(e[u]) && !wt(e[u]) ? C(i) || Fe(t[u]) ? t[u] = Array.isArray(e[u]) ? ke(e[u], []) : y({}, ke(e[u])) : xt(e[u], M(i) ? {} : i[u], t[u]) : t[u] = !re(e[u], i[u]);
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance7.exports;
        return __exports.data(L(e) || r ? 1 : 0);
    })();
    return t;
}
var Re = (e, i) => xt(e, i, ke(i)), mt = (e, {
        valueAsNumber: i,
        valueAsDate: t,
        setValueAs: r
    }) => C(e) ? e : i ? e === lS(0, 33) ? NaN : e && +e : t && J(e) ? new Date(e) : r ? r(e) : e;
function Te(e) {
    const i = e.ref;
    if (!(e.refs ? e.refs.every(t => t.disabled) : i.disabled))
        return Ie(i) ? i.files : je(i) ? _t(e.refs).value : Vt(i) ? [...i.selectedOptions].map(({value: t}) => t) : ge(i) ? bt(e.refs).value : mt(C(i.value) ? e.ref.value : i.value, e);
}
var Ht = (e, i, t, r) => {
        const u = {};
        for (const a of e) {
            const o = f(i, a);
            o && S(u, a, o._f);
        }
        return {
            criteriaMode: t,
            names: [...e],
            fields: u,
            shouldUseNativeValidation: r
        };
    }, ye = e => C(e) ? e : Ae(e) ? e.source : L(e) ? Ae(e.value) ? e.value.source : e.value : e, $t = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function at(e, i, t) {
    const r = f(e, t);
    if (r || Ne(t))
        return {
            error: r,
            name: t
        };
    const u = t.split(lS(0, 34));
    for (; u.length;) {
        const a = u.join(lS(0, 35)), o = f(i, a), b = f(e, a);
        if (o && !Array.isArray(o) && t !== a)
            return { name: t };
        if (b && b.type)
            return {
                name: a,
                error: b
            };
        (() => {
            const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        u.pop();
                    }
                }
            });
            const __exports = __callInstance3.exports;
            return __exports.data();
        })();
    }
    return { name: t };
}
var zt = (e, i, t, r, u) => u.isOnAll ? !1 : !t && u.isOnTouch ? !(i || e) : (t ? r.isOnBlur : u.isOnBlur) ? !e : (t ? r.isOnChange : u.isOnChange) ? e : !0, Gt = (e, i) => !ve(f(e, i)).length && R(e, i);
const Jt = {
    mode: W.onSubmit,
    reValidateMode: W.onChange,
    shouldFocusError: !0
};
function Kt(e = {}, i) {
    let t = y(y({}, Jt), e), r = {
            submitCount: 0,
            isDirty: !1,
            isLoading: ee(t.defaultValues),
            isValidating: !1,
            isSubmitted: !1,
            isSubmitting: !1,
            isSubmitSuccessful: !1,
            isValid: !1,
            touchedFields: {},
            dirtyFields: {},
            errors: {}
        }, u = {}, a = L(t.defaultValues) || L(t.values) ? q(t.defaultValues || t.values) || {} : {}, o = t.shouldUnregister ? {} : q(a), b = {
            action: !1,
            mount: !1,
            watch: !1
        }, h = {
            mount: new Set(),
            unMount: new Set(),
            array: new Set(),
            watch: new Set()
        }, k, D = 0;
    const A = {
            isDirty: !1,
            dirtyFields: !1,
            touchedFields: !1,
            isValidating: !1,
            isValid: !1,
            errors: !1
        }, _ = {
            values: Le(),
            array: Le(),
            state: Le()
        }, H = e.resetOptions && e.resetOptions.keepDirtyValues, T = tt(t.mode), Se = tt(t.reValidateMode), he = t.criteriaMode === W.all, De = s => n => {
            clearTimeout(D), D = setTimeout(s, n);
        }, V = s => G(this, null, function* () {
            if (A.isValid || s) {
                const n = t.resolver ? I((yield $()).errors) : yield Q(u, !0);
                n !== r.isValid && _.state.next({ isValid: n });
            }
        }), j = s => A.isValidating && _.state.next({ isValidating: s }), K = (s, n = [], l, g, d = !0, c = !0) => {
            (() => {
                const __ifInstance8 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                (() => {
                                    const __ifInstance9 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    const v = l(f(u, s), g.argA, g.argB);
                                                    d && S(u, s, v);
                                                }
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance9.exports;
                                    return __exports.data((b.action = !0, c && Array.isArray(f(u, s))) ? 1 : 0);
                                })();
                                (() => {
                                    const __ifInstance10 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    const v = l(f(r.errors, s), g.argA, g.argB);
                                                    d && S(r.errors, s, v), Gt(r.errors, s);
                                                }
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance10.exports;
                                    return __exports.data(c && Array.isArray(f(r.errors, s)) ? 1 : 0);
                                })();
                                (() => {
                                    const __ifInstance11 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    const v = l(f(r.touchedFields, s), g.argA, g.argB);
                                                    d && S(r.touchedFields, s, v);
                                                }
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance11.exports;
                                    return __exports.data(A.touchedFields && c && Array.isArray(f(r.touchedFields, s)) ? 1 : 0);
                                })();
                                A.dirtyFields && (r.dirtyFields = Re(a, o)), _.state.next({
                                    name: s,
                                    isDirty: w(s, n),
                                    dirtyFields: r.dirtyFields,
                                    errors: r.errors,
                                    isValid: r.isValid
                                });
                            }
                        },
                        impFunc2: () => {
                            (() => {
                                const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            S(o, s, n);
                                        }
                                    }
                                });
                                const __exports = __callInstance2.exports;
                                return __exports.data();
                            })();
                        }
                    }
                });
                const __exports = __ifInstance8.exports;
                return __exports.data(g && l ? 1 : 0);
            })();
        }, O = (s, n) => {
            S(r.errors, s, n), _.state.next({ errors: r.errors });
        }, oe = (s, n, l, g) => {
            const d = f(u, s);
            (() => {
                const __ifInstance12 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const c = f(o, s, C(l) ? f(a, s) : l);
                                C(c) || g && g.defaultChecked || n ? S(o, s, n ? c : Te(d._f)) : N(s, c), b.mount && V();
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance12.exports;
                return __exports.data(d ? 1 : 0);
            })();
        }, ue = (s, n, l, g, d) => {
            let c = !1, v = !1;
            const m = { name: s };
            (() => {
                const __ifInstance13 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                A.isDirty && (v = r.isDirty, r.isDirty = m.isDirty = w(), c = v !== m.isDirty);
                                const F = re(f(a, s), n);
                                v = f(r.dirtyFields, s), F ? R(r.dirtyFields, s) : S(r.dirtyFields, s, !0), m.dirtyFields = r.dirtyFields, c = c || A.dirtyFields && v !== !F;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance13.exports;
                return __exports.data(!l || g ? 1 : 0);
            })();
            (() => {
                const __ifInstance14 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const F = f(r.touchedFields, s);
                                F || (S(r.touchedFields, s, l), m.touchedFields = r.touchedFields, c = c || A.touchedFields && F !== l);
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance14.exports;
                return __exports.data(l ? 1 : 0);
            })();
            return c && d && _.state.next(m), c ? m : {};
        }, pe = (s, n, l, g) => {
            const d = f(r.errors, s), c = A.isValid && Z(n) && r.isValid !== n;
            (() => {
                const __ifInstance15 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const v = P(y(y({}, g), c && Z(n) ? { isValid: n } : {}), {
                                    errors: r.errors,
                                    name: s
                                });
                                r = y(y({}, r), v), _.state.next(v);
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance15.exports;
                return __exports.data((e.delayError && l ? (k = De(() => O(s, l)), k(e.delayError)) : (clearTimeout(D), k = null, l ? S(r.errors, s, l) : R(r.errors, s)), (l ? !re(d, l) : d) || !I(g) || c) ? 1 : 0);
            })();
            (() => {
                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            j(!1);
                        }
                    }
                });
                const __exports = __callInstance1.exports;
                return __exports.data();
            })();
        }, $ = s => G(this, null, function* () {
            return t.resolver(o, t.context, Ht(s || h.mount, u, t.criteriaMode, t.shouldUseNativeValidation));
        }), te = s => G(this, null, function* () {
            const {errors: n} = yield $(s);
            (() => {
                const __ifInstance16 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (const l of s) {
                                const g = f(n, l);
                                g ? S(r.errors, l, g) : R(r.errors, l);
                            }
                        },
                        impFunc2: () => {
                            r.errors = n;
                        }
                    }
                });
                const __exports = __ifInstance16.exports;
                return __exports.data(s ? 1 : 0);
            })();
            return n;
        }), Q = (g, d, ...c) => G(this, [
            g,
            d,
            ...c
        ], function* (s, n, l = { valid: !0 }) {
            for (const m in s) {
                const F = s[m];
                if (F) {
                    const v = F, {_f: U} = v, be = de(v, [lS(0, 36)]);
                    if (U) {
                        const ne = h.array.has(U.name), Y = yield lt(F, o, he, t.shouldUseNativeValidation && !n, ne);
                        if (Y[U.name] && (l.valid = !1, n))
                            break;
                        !n && (f(Y, U.name) ? ne ? It(r.errors, Y, U.name) : S(r.errors, U.name, Y[U.name]) : R(r.errors, U.name));
                    }
                    be && (yield Q(be, n, l));
                }
            }
            return l.valid;
        }), x = () => {
            for (const s of h.unMount) {
                const n = f(u, s);
                n && (n._f.refs ? n._f.refs.every(l => !Oe(l)) : !Oe(n._f.ref)) && Ee(s);
            }
            h.unMount = new Set();
        }, w = (s, n) => (s && n && S(o, s, n), !re(qe(), a)), E = (s, n, l) => vt(s, h, y({}, b.mount ? o : C(n) ? a : J(s) ? { [s]: n } : n), l, n), B = s => ve(f(b.mount ? o : a, s, e.shouldUnregister ? f(a, s, []) : [])), N = (s, n, l = {}) => {
            const g = f(u, s);
            let d = n;
            (() => {
                const __ifInstance17 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const c = g._f;
                                c && (!c.disabled && S(o, s, mt(n, c)), d = me(c.ref) && M(n) ? lS(0, 37) : n, Vt(c.ref) ? [...c.ref.options].forEach(v => v.selected = d.includes(v.value)) : c.refs ? ge(c.ref) ? c.refs.length > 1 ? c.refs.forEach(v => (!v.defaultChecked || !v.disabled) && (v.checked = Array.isArray(d) ? !!d.find(m => m === v.value) : d === v.value)) : c.refs[0] && (c.refs[0].checked = !!d) : c.refs.forEach(v => v.checked = v.value === d) : Ie(c.ref) ? c.ref.value = lS(0, 38) : (c.ref.value = d, c.ref.type || _.values.next({
                                    name: s,
                                    values: y({}, o)
                                })));
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance17.exports;
                return __exports.data(g ? 1 : 0);
            })();
            (l.shouldDirty || l.shouldTouch) && ue(s, d, l.shouldTouch, l.shouldDirty, !0), l.shouldValidate && fe(s);
        }, z = (s, n, l) => {
            for (const g in n) {
                const d = n[g], c = `${ s }.${ g }`, v = f(u, c);
                (h.array.has(s) || !Fe(d) || v && !v._f) && !ae(d) ? z(c, d, l) : N(c, d, l);
            }
        }, se = (s, n, l = {}) => {
            const g = f(u, s), d = h.array.has(s), c = q(n);
            S(o, s, c), d ? (_.array.next({
                name: s,
                values: y({}, o)
            }), (A.isDirty || A.dirtyFields) && l.shouldDirty && _.state.next({
                name: s,
                dirtyFields: Re(a, o),
                isDirty: w(s, c)
            })) : g && !g._f && !M(c) ? z(s, c, l) : N(s, c, l), st(s, h) && _.state.next(y({}, r)), _.values.next({
                name: s,
                values: y({}, o)
            }), !b.mount && i();
        }, ce = s => G(this, null, function* () {
            const n = s.target;
            let l = n.name, g = !0;
            const d = f(u, l), c = () => n.type ? Te(d._f) : ct(s);
            if (d) {
                let v, m;
                const F = c(), U = s.type === xe.BLUR || s.type === xe.FOCUS_OUT, be = !$t(d._f) && !t.resolver && !f(r.errors, l) && !d._f.deps || zt(U, f(r.touchedFields, l), r.isSubmitted, Se, T), ne = st(l, h, U);
                S(o, l, F), U ? (d._f.onBlur && d._f.onBlur(s), k && k(0)) : d._f.onChange && d._f.onChange(s);
                const Y = ue(l, F, U, !1), St = !I(Y) || ne;
                if (!U && _.values.next({
                        name: l,
                        type: s.type,
                        values: y({}, o)
                    }), be)
                    return A.isValid && V(), St && _.state.next(y({ name: l }, ne ? {} : Y));
                if (!U && ne && _.state.next(y({}, r)), j(!0), t.resolver) {
                    const {errors: Qe} = yield $([l]), Dt = at(r.errors, u, l), Xe = at(Qe, u, Dt.name || l);
                    v = Xe.error, l = Xe.name, m = I(Qe);
                } else
                    v = (yield lt(d, o, he, t.shouldUseNativeValidation))[l], g = Number.isNaN(F) || F === f(o, l, F), g && (v ? m = !1 : A.isValid && (m = yield Q(u, !0)));
                g && (d._f.deps && fe(d._f.deps), pe(l, m, v, Y));
            }
        }), fe = (l, ...g) => G(this, [
            l,
            ...g
        ], function* (s, n = {}) {
            let d, c;
            const v = Ve(s);
            if (j(!0), t.resolver) {
                const m = yield te(C(s) ? s : v);
                d = I(m), c = s ? !v.some(F => f(m, F)) : d;
            } else
                s ? (c = (yield Promise.all(v.map(m => G(this, null, function* () {
                    const F = f(u, m);
                    return yield Q(F && F._f ? { [m]: F } : F);
                })))).every(Boolean), !(!c && !r.isValid) && V()) : c = d = yield Q(u);
            return _.state.next(P(y(y({}, !J(s) || A.isValid && d !== r.isValid ? {} : { name: s }), t.resolver || !s ? { isValid: d } : {}), {
                errors: r.errors,
                isValidating: !1
            })), n.shouldFocus && !c && Ue(u, m => m && f(r.errors, m), s ? v : h.mount), c;
        }), qe = s => {
            const n = y(y({}, a), b.mount ? o : {});
            return C(s) ? n : J(s) ? f(n, s) : s.map(l => f(n, l));
        }, We = (s, n) => ({
            invalid: !!f((n || r).errors, s),
            isDirty: !!f((n || r).dirtyFields, s),
            isTouched: !!f((n || r).touchedFields, s),
            error: f((n || r).errors, s)
        }), At = s => {
            s && Ve(s).forEach(n => R(r.errors, n)), _.state.next({ errors: s ? r.errors : {} });
        }, He = (s, n, l) => {
            const g = (f(u, s, { _f: {} })._f || {}).ref;
            S(r.errors, s, P(y({}, n), { ref: g })), _.state.next({
                name: s,
                errors: r.errors,
                isValid: !1
            }), l && l.shouldFocus && g && g.focus && g.focus();
        }, Ft = (s, n) => ee(s) ? _.values.subscribe({ next: l => s(E(void 0, n), l) }) : E(s, n, !0), Ee = (s, n = {}) => {
            for (const l of s ? Ve(s) : h.mount)
                h.mount.delete(l), h.array.delete(l), n.keepValue || (R(u, l), R(o, l)), !n.keepError && R(r.errors, l), !n.keepDirty && R(r.dirtyFields, l), !n.keepTouched && R(r.touchedFields, l), !t.shouldUnregister && !n.keepDefaultValue && R(a, l);
            _.values.next({ values: y({}, o) }), _.state.next(y(y({}, r), n.keepDirty ? { isDirty: w() } : {})), !n.keepIsValid && V();
        }, $e = ({
            disabled: s,
            name: n,
            field: l,
            fields: g
        }) => {
            (() => {
                const __ifInstance18 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const d = s ? void 0 : f(o, n, Te(l ? l._f : f(g, n)._f));
                                S(o, n, d), ue(n, d, !1, !1, !0);
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance18.exports;
                return __exports.data(Z(s) ? 1 : 0);
            })();
        }, Ce = (s, n = {}) => {
            let l = f(u, s);
            const g = Z(n.disabled);
            return S(u, s, P(y({}, l || {}), {
                _f: y(P(y({}, l && l._f ? l._f : { ref: { name: s } }), {
                    name: s,
                    mount: !0
                }), n)
            })), h.mount.add(s), l ? $e({
                field: l,
                disabled: n.disabled,
                name: s
            }) : oe(s, !0, n.value), P(y(y({}, g ? { disabled: n.disabled } : {}), t.progressive ? {
                required: !!n.required,
                min: ye(n.min),
                max: ye(n.max),
                minLength: ye(n.minLength),
                maxLength: ye(n.maxLength),
                pattern: ye(n.pattern)
            } : {}), {
                name: s,
                onChange: ce,
                onBlur: ce,
                ref: d => {
                    if (d) {
                        Ce(s, n), l = f(u, s);
                        const c = C(d.value) && d.querySelectorAll && d.querySelectorAll(lS(0, 39))[0] || d, v = Wt(c), m = l._f.refs || [];
                        if (v ? m.find(F => F === c) : c === l._f.ref)
                            return;
                        S(u, s, {
                            _f: y(y({}, l._f), v ? {
                                refs: [
                                    ...m.filter(Oe),
                                    c,
                                    ...Array.isArray(f(a, s)) ? [{}] : []
                                ],
                                ref: {
                                    type: c.type,
                                    name: s
                                }
                            } : { ref: c })
                        }), oe(s, !1, void 0, c);
                    } else
                        l = f(u, s, {}), l._f && (l._f.mount = !1), (t.shouldUnregister || n.shouldUnregister) && !(ft(h.array, s) && b.action) && h.unMount.add(s);
                }
            });
        }, ze = () => t.shouldFocusError && Ue(u, s => s && f(r.errors, s), h.mount), Ge = (s, n) => l => G(this, null, function* () {
            l && (l.preventDefault && l.preventDefault(), l.persist && l.persist());
            let g = q(o);
            if (_.state.next({ isSubmitting: !0 }), t.resolver) {
                const {
                    errors: d,
                    values: c
                } = yield $();
                r.errors = d, g = c;
            } else
                yield Q(u);
            R(r.errors, lS(0, 40)), I(r.errors) ? (_.state.next({ errors: {} }), yield s(g, l)) : (n && (yield n(y({}, r.errors), l)), ze(), setTimeout(ze)), _.state.next({
                isSubmitted: !0,
                isSubmitting: !1,
                isSubmitSuccessful: I(r.errors),
                submitCount: r.submitCount + 1,
                errors: r.errors
            });
        }), kt = (s, n = {}) => {
            f(u, s) && (C(n.defaultValue) ? se(s, f(a, s)) : (se(s, n.defaultValue), S(a, s, n.defaultValue)), n.keepTouched || R(r.touchedFields, s), n.keepDirty || (R(r.dirtyFields, s), r.isDirty = n.defaultValue ? w(s, f(a, s)) : w()), n.keepError || (R(r.errors, s), A.isValid && V()), _.state.next(y({}, r)));
        }, Je = (s, n = {}) => {
            const l = s ? q(s) : a, g = q(l), d = s && !I(s) ? g : a;
            if (n.keepDefaultValues || (a = l), !n.keepValues) {
                if (n.keepDirtyValues || H)
                    for (const c of h.mount)
                        f(r.dirtyFields, c) ? S(d, c, f(o, c)) : se(c, f(d, c));
                else {
                    if (Me && C(s))
                        for (const c of h.mount) {
                            const v = f(u, c);
                            if (v && v._f) {
                                const m = Array.isArray(v._f.refs) ? v._f.refs[0] : v._f.ref;
                                if (me(m)) {
                                    const F = m.closest(lS(0, 41));
                                    if (F) {
                                        (() => {
                                            const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                                                env: {
                                                    impFunc: () => {
                                                        F.reset();
                                                    }
                                                }
                                            });
                                            const __exports = __callInstance0.exports;
                                            return __exports.data();
                                        })();
                                        break;
                                    }
                                }
                            }
                        }
                    u = {};
                }
                o = e.shouldUnregister ? n.keepDefaultValues ? q(a) : {} : q(d), _.array.next({ values: y({}, d) }), _.values.next({ values: y({}, d) });
            }
            h = {
                mount: new Set(),
                unMount: new Set(),
                array: new Set(),
                watch: new Set(),
                watchAll: !1,
                focus: ''
            }, !b.mount && i(), b.mount = !A.isValid || !!n.keepIsValid, b.watch = !!e.shouldUnregister, _.state.next({
                submitCount: n.keepSubmitCount ? r.submitCount : 0,
                isDirty: n.keepDirty ? r.isDirty : !!(n.keepDefaultValues && !re(s, a)),
                isSubmitted: n.keepIsSubmitted ? r.isSubmitted : !1,
                dirtyFields: n.keepDirtyValues ? r.dirtyFields : n.keepDefaultValues && s ? Re(a, s) : {},
                touchedFields: n.keepTouched ? r.touchedFields : {},
                errors: n.keepErrors ? r.errors : {},
                isSubmitSuccessful: n.keepIsSubmitSuccessful ? r.isSubmitSuccessful : !1,
                isSubmitting: !1
            });
        }, Ke = (s, n) => Je(ee(s) ? s(o) : s, n);
    return {
        control: {
            register: Ce,
            unregister: Ee,
            getFieldState: We,
            handleSubmit: Ge,
            setError: He,
            _executeSchema: $,
            _getWatch: E,
            _getDirty: w,
            _updateValid: V,
            _removeUnmounted: x,
            _updateFieldArray: K,
            _updateDisabledField: $e,
            _getFieldArray: B,
            _reset: Je,
            _resetDefaultValues: () => ee(t.defaultValues) && t.defaultValues().then(s => {
                Ke(s, t.resetOptions), _.state.next({ isLoading: !1 });
            }),
            _updateFormState: s => {
                r = y(y({}, r), s);
            },
            _subjects: _,
            _proxyFormState: A,
            get _fields() {
                return u;
            },
            get _formValues() {
                return o;
            },
            get _state() {
                return b;
            },
            set _state(s) {
                b = s;
            },
            get _defaultValues() {
                return a;
            },
            get _names() {
                return h;
            },
            set _names(s) {
                h = s;
            },
            get _formState() {
                return r;
            },
            set _formState(s) {
                r = s;
            },
            get _options() {
                return t;
            },
            set _options(s) {
                t = y(y({}, t), s);
            }
        },
        trigger: fe,
        register: Ce,
        handleSubmit: Ge,
        watch: Ft,
        setValue: se,
        getValues: qe,
        reset: Ke,
        resetField: kt,
        clearErrors: At,
        unregister: Ee,
        setError: He,
        setFocus: (s, n = {}) => {
            const l = f(u, s), g = l && l._f;
            (() => {
                const __ifInstance19 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const d = g.refs ? g.refs[0] : g.ref;
                                d.focus && (d.focus(), n.shouldSelect && d.select());
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance19.exports;
                return __exports.data(g ? 1 : 0);
            })();
        },
        getFieldState: We
    };
}
function ns(e = {}) {
    const i = p.useRef(), t = p.useRef(), [r, u] = p.useState({
            isDirty: !1,
            isValidating: !1,
            isLoading: ee(e.defaultValues),
            isSubmitted: !1,
            isSubmitting: !1,
            isSubmitSuccessful: !1,
            isValid: !1,
            submitCount: 0,
            dirtyFields: {},
            touchedFields: {},
            errors: {},
            defaultValues: ee(e.defaultValues) ? void 0 : e.defaultValues
        });
    i.current || (i.current = P(y({}, Kt(e, () => u(o => y({}, o)))), { formState: r }));
    const a = i.current.control;
    return a._options = e, Pe({
        subject: a._subjects.state,
        next: o => {
            yt(o, a._proxyFormState, a._updateFormState, !0) && u(y({}, a._formState));
        }
    }), p.useEffect(() => {
        e.values && !re(e.values, t.current) ? (a._reset(e.values, a._options.resetOptions), t.current = e.values) : a._resetDefaultValues();
    }, [
        e.values,
        a
    ]), p.useEffect(() => {
        a._state.mount || (a._updateValid(), a._state.mount = !0), a._state.watch && (a._state.watch = !1, a._subjects.state.next(y({}, a._formState))), a._removeUnmounted();
    }), i.current.formState = dt(r, a), i.current;
}
export {
    us as C,
    rs as I,
    is as L,
    ss as S,
    Be as a,
    f as g,
    ns as u
};</script>
</body>
</html>
